<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>

<script>

  // 1. JS作用域链的理解?
  //    函数内访问变量时, 优先访问自己作用域的
  //    如果自己作用域没有, 向外访问外层作用域 ... 直到全局

  //    函数执行, 有着可执行上下文, 每个可执行上下文, 有着对于外部上下文的词法作用域的引用
  //    外部上下文, 又有着对于它外部的词法作用域的引用, 最终找到全局的可执行上下文...
  //    就形成了作用域链

  // 2. 闭包?
  //    内部函数引用了外部函数的变量, 就形成了闭包
  //    作用: 实现数据私有
  //    闭包的内存泄漏  p = null (垃圾回收机制, 引用计数(循环引用), 标记清除)

  // 3. 原型链
  //    了解原型链的目的: 了解到一个实例, 能够用多少属性和方法
  //    构造函数 实例 原型 (三角关系图)

  //    实例在访问属性时, 优先使用自己的, 如果自己没有, 找原型, 如果原型还没有, 找原型的原型....
  //    这个链式关系, 就是原型链

  // 4. 继承
  //    为什么要有继承? 没有继承, 所有的构造函数没有关联, 构建属性的过程, 方法, 都需要实现很多遍
  //    人类, 学生, 工人
  //    为了 => 构造函数的复用 和 便于构造函数的管理

  //    什么是继承? 自己没有的东西, 从别人那边拿 (家产, 房产...)
  //    在js中, 继承 => 继承方法, 继承构造属性的过程

  //    继承的方案:
  //    1. 原型继承: 改写原型链
  //       子构造函数.prototype = new 父构造函数()
  //    2. 组合式继承
  //       (1) 原型链
  //       (2) 构造函数借调 call
  //    3. 寄生组合式继承
  //       Object.create(对象)
  //       (1) 创建一个新对象
  //       (2) 让新对象的 __proto__ 指向传入的对象
  //    4. es6 class extends

  //   this指向的情况:
  //   1. 函数调用模式 fn()
  //   2. 方法调用模式 obj.fn()
  //   3. 上下文调用模式 call apply bind
  //   4. 构造函数模式 new


  // get 和 post的区别
  // 1. get在地址栏传参,  post在请求体
  // 2. get暴露在地址栏, 相对不安全, post在请求体
  // 3. get受到地址栏的长度限制, post传输大文件
  // 4. get仅支持正常的字符, post支持任意类型(2进制, 字节流)
  // 5. get幂等, post非幂等

  // 请求报文和响应报文的组成部分
  // 请求报文:
  // 1. 请求行
  // 2. 请求头
  // 3. 请求体

  // 响应报文:
  // 1. 响应行
  // 2. 响应头
  // 3. 响应体

  // 常见的状态码
  // 2xx   200成功  201创建
  // 3xx   301 302 307重定向,  304协商缓存(缓存处理的)
  // 4xx   400 401
  // 5xx   服务器错误



</script>
  
</body>
</html>