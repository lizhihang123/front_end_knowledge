<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>实现resolve的值是promise实例</title>
</head>
<body>
<script>
  const PENDING = 'pending'
  const FULFILLED = 'fulfilled'
  const REJECTED = 'rejected'

  class Promise2 {
    static resolve(value) {
      if (value instanceof this) {
        return value
      }
      return new this((resolve, reject) => {
        resolve(value)
      })
    }

    static reject(reason) {
      return new this((resolve, reject) => {
        reject(reason)
      })
    }

    static all(promises) {
      return new this((resolve, reject) => {
        let promiseNum = promises.length
        let resolvedNum = 0
        let resolvedValues = new Array(promiseNum)
        for (let i = 0; i < promiseNum; i++) {
          this.resolve(promises[i]).then(val => {
              resolvedNum++
              resolvedValues[i] = val
              if (resolvedNum === promiseNum) { //所有的promise都已经解决
                resolve(resolvedValues)
              }
            },
            reason => {
              reject(reason)
            }
          )
        }

      })
    }

    static race(promises) {
      return new this((resolve,reject) => {
        let length = promises.length
        for (let i = 0; i < length; i++) {
          this.resolve(promises[i]).then(
            value => {
              resolve(value)
            },
            reason => {
              reject(reason)
            }
          )
        }

      })
    }

    constructor(executor) {
      this.status = 'pending'
      this.value = null
      this.reason = null
      this.onFulfilledCallbacks = [] //成功的回调队列
      this.onRejectedCallbacks = [] //失败的回调队列
      const resolve = (value) => {
        if (value instanceof this.constructor) {
          value.then(resolve, reject) //promise2解决后，将外层的promise也解决
          return
        }
        if (this.status === PENDING) {
          this.status = FULFILLED
          this.value = value
          setTimeout(() => {
            this.onFulfilledCallbacks.forEach(callback => {
              callback(this.value)
            })
          })
        }
      }
      const reject = (reason) => {
        if (this.status === PENDING) {
          this.status = REJECTED
          this.reason = reason
          setTimeout(() => {
            this.onRejectedCallbacks.forEach(callback => {
              callback(this.reason)
            })
          })
        }
      }
      executor(resolve, reject)
    }

    then(onFulfilled, onRejected) {
      const p2 = new this.constructor((resolve, reject) => {
        if (this.status === FULFILLED) {
          setTimeout(() => {
            try {
              let callbackValue = onFulfilled(this.value)
              resolve(callbackValue)
            } catch (error) {
              reject(error)
            }

          })
        }

        if (this.status === REJECTED) {
          setTimeout(() => {
            try {
              let callbackValue = onRejected(this.reason)
              resolve(callbackValue)
            } catch (error) {
              reject(error)
            }

          })
        }
        if (this.status === PENDING) {
          this.onFulfilledCallbacks.push(() => {
            try {
              let callbackValue = onFulfilled(this.value)
              resolve(callbackValue)
            } catch (error) {
              reject(error)
            }
          })
          this.onRejectedCallbacks.push(() => {
            try {
              let callbackValue = onRejected(this.reason)
              resolve(callbackValue)
            } catch (error) {
              reject(error)
            }
          })
        }
      })
      return p2
    }

    catch(onRejected) {
      return this.then(null, onRejected)
    }
  }


  // let p = new Promise2((resolve,reject) => {
  //   reject(1)
  // })
  //   p.catch(reason => {
  //     console.log(reason);
  //   })
  //let p = Promise2.resolve(1)
  // let p1 = new Promise2(resolve => {
  //   resolve(1)
  // })
  // let p2 = Promise2.resolve(p1)
  //let p = Promise2.reject(1)
  // let p1 = new Promise2((resolve,reject) => {
  //   reject(1)
  // })
  // let p2 = Promise2.reject(p1)

  /*Promise.all*/
  // let p = Promise.all([
  //   new Promise2((resolve,reject)=>{
  //     setTimeout(()=>{
  //       reject(1)
  //     },1000)
  //   }),
  //   new Promise((resolve,reject)=>{
  //     setTimeout(()=>{
  //       resolve(2)
  //     },2000)
  //   }),
  //   new Promise((resolve,reject)=>{
  //     setTimeout(()=>{
  //       resolve(3)
  //     },3000)
  //   }),
  // ])

  // let p = Promise2.race([
  //   1,
  //   new Promise2((resolve,reject)=>{
  //     setTimeout(()=>{
  //       resolve(2)
  //     },2000)
  //   }),
  //   new Promise2((resolve,reject)=>{
  //     setTimeout(()=>{
  //       resolve(3)
  //     },3000)
  //   }),
  // ])
  //   p.then(val => {
  //     console.log(val);
  //   })

  setTimeout(() => {
    console.log(1);
  }, 0)
  let p = Promise2.resolve(2)
  p.then((val) => {
    console.log(val);
  })
</script>
</body>
</html>