## 1. HTTP

### 2 报文结构是怎么样的？

```js
1. 分为header+body两个部分
具体就是 起始行，头部，空行，实体
2. 起始行长这样：
  GET /home HTTP/1.1
  响应报文长这样：
  HTTP/1.1 200 OK【http版本 状态码 原因】
3. 每两个部分之间用空行隔开。 请求行 请求头 空行 请求体
4. 字段要求：
   不区分大小写
   字段名后面不允许出现空格，不可以出现下划线
   字段名后面必须紧跟：
--
1. 空行用来干什么？
  区分请求头和请求体
  如果在头部后面故意加一个空行怎么办？
  那么空行后面所有的内容都会变成实体【请求体】
2. 实体：请求报文-请求体；响应报文-响应体
 
```

![image-20220805193402034](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4575/image-20220805193402034.png)



>引申的知识点 头部包含了哪些字段



### 3.如何理解http的请求方法

```js
get:获取资源
head:获取资源的元信息
post：提交信息
put：修改信息 完全修改
patch：修改信息 只修改一部分
delete：删除信息
connect:`建立连接隧道，用于代理服务器`
options：一般用来跨域请求。预检请求，和cors结合起来.
trace:追踪 请求响应的路径
```



### 4.get和post有什么区别：

```js
1. 语义不同：get是获取资源 post是提交信息，上传数据
2. 传参方式不同：get是通过地址栏传参，post是通过请求体传参
3. 携带的数据量是不同的：get通过地址栏，有大小的限制，限制是多少？；但是post没有
4. 安全：get不安全，因为地址栏暴露可见。post更安全，但是http里面的请求体也是明文的，也不安全。才会有后来的https
5. 幂等性：get请求具备幂等性，发一次和发十次，是没有区别的。但是post没有，因为post提交一次数据，就是一次新的请求
6. 编码角度：get只能进行url编码，只能接受ASCLL字符，而post没有限制
7. 缓存：get请求会被缓存下来，post不会
8. tcp的角度：get发请求是一次性发出去，但是post会把数据分为两个包，首先发header部分，返回100，再发送请求体的部分，（但是火狐浏览器post只会发送一次）
```



>get请求数据 大小的限制是多少？
>
>https 关联知识点



### 5.如何理解URI

`统一资源定位符` `区分不同资源` `URL URN` `完整结构 协议 主机名和端口 path 查询参数`

`编码 ACSLL + 编码为十六进制`

```js
1. URI - uniform resource identifier 统一资源标识符 ，
  作用就是用于区分：互联网上不同的资源
2. 包括URL和URN
3. 完整结构是：
  协议+用户信息+主机名+端口+path+查询参数+对应资源的一个锚点【浏览器根据这个锚点 定位到对应的位置 => 怪兽追踪器】
  https://www.baidu.com/s?wd=HTTP&rsv_spt=1
  https 协议
  www.baidu.com 主机名+端口
  /s path
  wd=HTTP&rsv_spt=1 查询参数
 4. 浏览器默认http默认端口是80
   https默认端口是443
 5. 编码：只能使用ASCLL编码，之外的字符是不支持显示的，还有一部分符号是界定符。界定符会被进行编码，所有非ASCLL码字符和界定符转为十六进制字节值，前面加个%。空格被定义未%
```



### 6.HTTP的状态码：

```js
1xx接受的请求 正在处理
2xx成功
3xx资源位置发生变动
4xx请求报文有误
5xx服务端发生错误
```



```js
101 http -> websocket 服务器同意变更

200 成功 响应体里面有数据
204 处理成功 但是没有数据可以返回
206 请求一部分数据，content-range字段表示资源的范围。http 分段下载+断点续传

301 永久重定向 
   从http -> https 以前的站点再也不用了，浏览器默认做缓存优化
   请求的资源被分配了新的uri，就会返回301.要去更新书签
302 临时重定向 浏览器不会做缓存优化。只是临时换了一个访问的地址.不用更新书签
303 资源的uri更新，要使用`get`而不是post方法去访问这个资源。
304 `协商缓存`命中时，会返回这个状态码。和重定向没有关系
   有权限访问这个资源，但是服务端资源没有发生变化。浏览器可以直接使用本地的资源。
307 临时重定向 和302类似，但是307不允许`方法`比如get -> post发生改变。而302尽管不允许，但是大家不遵守。

400 请求报文中存在语法问题。笼统提示错误，不知道哪里错了
401 需要用户进行认证 + 用户认证失败
403 服务器禁止访问。可能是用户没有权限，法律禁止等等
404 资源没有找到。也有可能是服务端拒绝请求，但是没有说明理由
405 请求方法不被客户端允许
406 资源无法满足客户端要求
408 服务端等待太长时间
409 多个请求发生冲突
413 Request Entity Too Large请求体的数据过大
414 Request-URI Too Long 请求行里面的uri过大
429 客户端发送的请求过多
431 Request Header Fields Too Large 请求头的字段内容太大


500 仅仅告诉你服务器出错，啥错误 不知道呀。也有可能是web端存在的某些bug
501 Not Implemented 客户端请求的功能还不支持
502 服务器自身正常，但是访问的时候出错了，咱也不知道
503 服务端很忙，没法响应
```



### 7. 简要概括一下http的特点

```js
1. 灵活可扩展
  语义自由 + 传输形式多样式
  只规定了基本的格式，分隔字段，请求行 请求头 空行 + 图片 视频 文本 都可以被传输
2. 可靠传输 http基于tcp的特性
  继承了TCP/IP的特性，注意区别UDP
3. 请求应答 一发一收 有来有回
  某个服务器作为中转站，反向代理，客户端借助一个服务器1 向另一台服务器2发信息
4. 无状态 
  每次http的请求都是`独立的``无关`的 默认不需要保留
```



缺点：

```js
1. 无状态
  需要保存 大量的上下文信息时，避免传输重复的数据，无状态就是缺点
  某些场景，仅仅是为了获取一些数据，不需要保存连接上下文信息，就是优点
  
 2. 明文
   不使用二进制数据 而是文本
   不安全，尽管有利于调试信息
 3. 队头阻塞
   同一个时刻 只能处理一个请求，当前请求耗时过长时，其它的请求会处于阻塞状态
```





### 8. 对Accept字段了解多少

```js
1 数据格式
  MIME标准 - 邮件 - 多种类型的数据 - 请求体里面 -
  text： text/html, text/plain, text/css
  application: application/json, application/javascript, application/pdf, application/octet-stream
  image: image/gif, image/jpeg, image/png
  audio/video: audio/mpeg, video/mp4 

2 压缩方式
接收端：Content-Encoding: gzip
发送端：Accept-Encoding: gzip
>gzip：最流行的压缩方式
 deflate：另一种著名
 br【】：专门为http发明的压缩算法

3 支持语言 
Content-Language: zh-CN, zh, en
接收端：Accept-Language: zh-CN, zh, en

4 字符集
Content-Type: text/html;charset=utf-8
接收端Accept-Charset: charset=urf-8

```



### 9.关于定长和不定长的数据 http是怎么传输的？

定长的包体，会指定 content-length，表示传输内容的宽度，

如果从长度短了，内容在传输的过程会被直接截取。

如果长度过长了，嘿嘿，直接无法显示内容啦



不定长数据：

Transfer-encoding 字段：

1. 请你忽略 content-length字段，他没用啦
2. 我这次的数据很多很大，要长连接推送，你忍耐一下哈

```diff
const http = require('http')
const server = http.createServer()

server.on('request', (req, res) => {
  if (req.url === '/') {
    // 表示文本text/plain
    // res.setHeader('content-type', 'text/plain')

    // text/html 表示传输html文件内容
+   res.setHeader('content-type', 'text/html; charset=utf8')
    res.setHeader('content-length', 10)
+    res.setHeader('Transfer-Encoding', 'chunked')
    res.write('<p>第一次传输</p><br />')
    setTimeout(() => {
      res.write('<p>第2次传输</p><br />')
    }, 1000)
    setTimeout(() => {
      res.write('<p>第3次传输</p><br />')
      // res.end()
    }, 3000)
  }
})

server.listen(8080, function () {
  console.log('this server is running at http://localhost:8080')
})

```



![image-20220809175133623](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4575/image-20220809175133623.png)





ping命令 不能用来ping本地开启的服务器？只能用来ping一个

![image-20220809174102073](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4575/image-20220809174102073.png)





### 10.http大文件传输

1. 如果数据量很大，几个G的资源，直接发送，是不现实的。HTTP支持`范围请求`的方法。

   如何实现呢？服务器加上响应头 `Accept-Ranges: none`  用来告知客户端 这边是支持范围请求的

2. 客户端通过Range字段 来向告诉服务器要请求多少的数据

​	格式 bytes=x-y

```js
	0-499: 表示从0开始到第499个字节

​	500-：表示第500个字节到文件终点

​	-100表示文件的最后100个字节
```

​	服务端收到后，判断参数是否合法，如果越界，返回`416错误码`

​	如果没有越界，就读取相应的片段，返回`206状态码`

​	同时服务器，要添加Content-Range字段，这个字段根据客户端请求头中的Range字段不同有所差异:

```js
// 单段数据：
Ranges: bytes=0-9

// 返回的响应体：
HTTP/1.1 206 Partial Content
Content-Length: 10
Accept-Ranges: bytes
Content-Range: bytes 0-9/100 // 0-9表示返回的资源序号，100表示资源的大小

i am xxxxx


```



// 多端数据
Ranges: bytes=0-9;30-39



多段数据的响应体：

```js
HTTP/1.1 206 Partial Content
Content-Type: multipart/byteranges; boundary=00000010101 // multipart/byteranges 表示多段数据 boundary=00000010101 表示不同段的数据的分割符号
Content-Length: 189 // 长度
Connection: keep-alive // 保持连接
Accept-Ranges: bytes


--00000010101
Content-Type: text/plain
Content-Range: bytes 0-9/96

i am xxxxx
--00000010101
Content-Type: text/plain
Content-Range: bytes 20-29/96

eex jspy e
--00000010101--
```





总结：

1. 服务端首先要能够支持范围请求，依靠字段`Accept-Ranges： none` 告诉客户端我支持范围请求

2. 请求多少的数据呢？客户端通过`Ranges字段`，

   `bytes=x-y` 具体的格式有要求 `1-9；``10-；``-100`表示的内容都是不同

3. 服务器根据客户端来的字段，是单段数据还是多段数据？

   不同类型，响应体也不同。如果是单段的，就返回`Content-Range: bytes 0-9/36`

   如果是多段的，就返回，`Content-Type: multipart/byteRange;boundary=1000001`同时`Content-Range：bytes 0-9/36` 36表示内容的大小



### 11. http如何处理表单数据的提交

1. 有两种表单表单提交的形式。表单提交默认是POST请求，数据要放在请求体当中

application/x-www-form-urlencoded

multipart/form-data

2. application/x-www-form-urlencoded

- 数据会被编码成以 &符分隔
- 字符以url编码方式编码

>{a: 1, b: 2} => "a%3D1%26b%3D2" // %3D1表示分号，%26表示逗号

3. multipart/form-data

- 请求头中的Content-Type字段会包含boundary,值是浏览器默认固定的，例如，`Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe`
- 数据分为多个部分，每个部分之间都有http头部来描述子包体，如Content-Type，在最后的分隔符上面会加--表示

```diff
Content-Disposition: form-data;name="data1";
Content-Type: text/plain
data1
----WebkitFormBoundaryRRJKeWfHPGrS4LKe
Content-Disposition: form-data;name="data2";
Content-Type: text/plain
data2
----WebkitFormBoundaryRRJKeWfHPGrS4LKe-- 这个--表示结束
```



总结：

1. 在实际的应用场景中，对于图片的上传，`multipart/form-data `是更加常用的，因为application/www-form-urlencoded是以url形式编码，不同参数之间用&符进行连接，耗费资源 性能和占用空间
2. multipart/form-data 能够将每个表单元素，独立的拆分开来。抓包工具可以看得到



### 12. http1.1 如何解决 队头阻塞的问题

1. 问题：http是基于请求应答模式，一问一答，但是如果这些任务被放在一个任务队列里面串行执行，就会阻塞后面的任务的处理。
2. 并发连接：RFC2616规范规定，客户端最多发两个长连接，但是实际上，比如谷歌浏览器可以有6个
3. 更好的满足需求【上面还是不能满足】：一个域名可以有6个长连接+一个域名下面可以分出很多的二级域名，它们都指向同一个服务器，能够并发更多的连接数量。

​	lizhihagn.com lizhihang2.com lizhihang3.com





### 13. 对cookie了解多少

1. 为什么需要cookie?

   http请求 是无状态的，存不住信息【默认不需要保存信息】，但有需要的场景，cookie可以来保存信息

2. cookie是什么

   本质是一个文件，浏览器打开`application`里面可以看到。

   而服务端可以通过 `set-cookie`来给客户端发送写入cookie。

   客户端每次请求携带cookie 能够让服务端识别客户端的状态，cookie有效期，路径，域名等信息

```js
// 请求头
cookie: a=xx；b=xxx
// 响应头
setCookie: a=xxx
setCookie：b=xxx
```

4. cookie的一些字段

   为cookie服务的首部字段

   `setcookie`和`cookie`

   

   Cookie字段

   ```js
   Cookie: status = enable // 表示开启cookie
   ```

   

   setCookie下面的一些字段：

   ```js
   Set-Cookie: status=enable;expires=Tue, 05, Jul 2011 07:26:31 GMT; => path=/; domain=.hacker.jp
   ```

   - expires=Data：cookie的有效期，如果不指定，浏览器关闭时，cookie就过期了。【绝对时间】
   - domanin=域名：不指定，就是默认创建的cookie的域名，比如指定example.com,那么www.example.com或者是`www.example.com`都可以发送Cookie。不指定域名，更加的安全
   - path=路径：将服务器上面的文件目录，作为cookie的使用对象。不指定，就是默认文档所在的目录。
   - secure: 只有在HTTPS开启时，才会发送cookie

   ```js
   Set-cookie: name=value secure;
   ```

   - HttpOnly: 使用cookie时，不能通过js脚本获取cookie,能够防止XSS【跨站脚本攻击】。`document.cookie`

   - SameSite: 能够防止CSRF攻击

     strict lax none

     `strict`：浏览器 禁止任何第三方携带cookie，请求hangzai.com 只能在 hangzai.com下携带cookie

     `lax`：第三方，只能是get请求或者a标签能够携带cookie

     `none`:任何情况都可以携带cookie

5. cookie的缺点：

   1. 容量小，只有4kb
   2. 不安全，容易被非法截取。
   3. 浪费性能：如果某些域名的二级域名，不需要cookie，但是还是会携带，就会造成性能的浪费。可以通过path和domain来设置





### 1.14 HTTP代理

1. 原本客户端和服务器之间是基于 请求响应模式，一般由客户端发请求，服务器响应，但是HTTP代理存在的时候，情况就会不一样。

2. 他的功能：

   `负载均衡`：http发送请求给代理服务器。这个请求后面要发送给多少个服务器，怎么分流，前端是不知道的，但是代理服务器要根据算法 比如hash算法 LRU算法，让各台服务器之间的`**负载尽量平均**，**压力小一些**`

   `保障安全`：**对非法的数据进行过滤，对非法的IP进行限制**。利用心跳机制 监控后台的服务器，一旦发生故障，就将他踢出集群。

   `缓存代理`：一些数据，可以直接**存到代理服务器**，而不是每次都从后端去拿，这样能够极大的减少服务器的请求。



3. 相关的头部字段：

   Via字段：代理服务器需要标明自己的身份。

   >客户端-> 代理服务器1 -》 代理服务器2 -》 服务器
   >
   >服务器收到请求头 包含 via proxy_serve1 proxy_serve2
   >
   >服务器-> 代理服务器2-》 代理服务器1 -》 客户端
   >
   >客户端收到 via proxy_serve2 proxy_serve1

   

   

   X-Forwarded-For字段：记录的是请求方的IP地址。注意是，请求方的IP

   

   

   X-Real-IP字段：

   ```js
   X-Forwarded-IP X-Forwarded-Host X-Forwarded-Proto
   
   用户真实的的IP 用户真实的的主机 用户的端协议名	
   ```





​	X-Forwarded-For 产生的问题：

​	>> 信息 从客户端 到代理1： 字段是客户端的IP

​	从代理1到代理2，字段是代理1的IP，

​    产生问题：1. 每次代理都要解析请求头，修改，转发，性能下降 2. https加密的过程中，原始报文是不允许修改的



>// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接收端口 PROXY TCP4 0.0.0.1 0.0.0.2 1111 2222 GET / HTTP/1.1

### 应用层（基于TCP）

hTTP协议是属于应用层的，用户最常接触的，输入网址，http前面会自动补齐为https；后面默认的会补齐一个80端口，是服务器响应的端口



最重要的是传输层，传数据；选择的是TCP，因为TCP是更可靠的，有三次握手机制；UDP可能返回的网页是缺斤少两的





### 非持久连接和持久连接

**非持久：**

客户端一次输入网址一个，请求一次资源，服务器响应完毕后续就关闭，这样能够节省资源。但是一次只能请求一个资源，不满足互联网的发展。

**持久连接：**

http1.x：客户端请求，服务端响应，客户端还可以再次请求。如果客户端不需要了，就发送一个connection:close关闭通道即可。







### 无状态和状态管理

无状态：

​	很多客户端发送请求给服务端，服务端如果都记录状态，会崩溃的，所以服务端不记录。这个就是http的无状态，是时间限制的。



状态管理：

​	用户登录一次，状态如果没有记录，下次还要重新记录是很痛苦的。因此需要一个cookie技术，用户每次访问时，带上cookie这个技术，就能够实现免登录了



## 1.1 http缓存

#### 缓存的基本认知

为什么需要缓存？

```diff
 一个篮子里面，有苹果，去数，1 2 3 有三个苹果，数了有三个，我再问一次，你不需要再数不需要费力气了，直接说3.但是如果个数发生了变化，就要重新去数，然后再记住这个数字。
+ 一句话 - 能够更加省式省力
```

#### 缓存分类

`浏览器缓存`、服务器缓存[CDN缓存、代理服务器缓存]、数据库缓存

```diff
数据库缓存，浏览器 -> 请求给服务器 -> 服务器收到 去数据库查信息 -> 第一次查到了 -> 假设服务器拿到了，要进行处理, 服务器存住 -> 就给到了浏览器 -> 下一次客户端再发请求 -> 如果请求的内容一致，服务器不需要再次去数据库查了
```



#### 测试 

打开控制台，去浏览器删除缓存ctrl + F5,观察，第一次进入后再，第二次进入时，发现disk-cache，就是表明有些数据是从缓存里面读来的

>1. data:image 表示是base64的图片 是从css里面进来的
>2. webp是一种经过压缩的格式，流行的趋势，1MB -》 100kb, 能够直接把数据的体积降下来



#### `强缓存`

```diff
1. 强缓存就是，判断资源是否在有效期内，如果在，直接获取资源，不发请求，如果不在，就发请求
2. 强缓存可以理解为，食品有效期，如果在有效期内，直接吃。如果不在，打电话问客服。
珠峰，如果氧气瓶过期，打电话问大本营能不能够用。
不过期，直接用
3. 强缓存需要用到的字段
expires 和 cache-control
+ 3.1 expires =》指的是绝对时间，是服务器的时间。缺陷：如果客户端修改了本地的时间，但是强缓存根据的服务器的时间，本地改为2012年 但是服务器还是2022年，就很久都不会命中强缓存。
- 爬珠峰，氧气瓶过期了， 打电话给大本营，是否有问题，大本营穿越了，时间在2022年，你的时间在2012年，很久都不会命中
expires: Fri, 01 Jan 1980 00:00:00 GMT 这个是标准时间
+ 3.2 cache-control =》相对时间，是浏览器的时间。相对于浏览器端的时间
cache-control: no-cache, max-age=0, must-revalidate

+ 3.3 
- 如果上两个字段同时存在，cache-con 为准 如果出现了混乱的话
- cache-control
可以多个字段存在
max-age 表示时间长度 单位s
no-cache 不是 不缓存 而是要 每次 问服务器能否读取缓存
no-store 表示是禁止缓存的意思

must-revalidate ? 啥意思
https://www.javaroad.cn/questions/94488
```



>强缓存 
>
>expire 是拿服务端的时间和你本地的时间进行对比
>
>cache-control 是拿你本地的时间 和 相对的时间 进行对比 3153600就是一年的s



#### `协商缓存`

```diff
如果一个食品已经过期了，可以选择直接扔掉的。
但是有可能，日期是过期了，但是实际还是能够吃的。你去问问专家，这个食品过期了之后还能不能吃。专家说可以，就还是可以吃。

比如一个资源已经过期。
你不是马上抛弃，还是拿着这个资源对应的一个标识去问问服务器，这个资源有没有发生变化，如果没有发生，变化，还是用这个资源，就可以不用变。服务器会返回状态码304。不会返回新的资源标识

如果发生了改变了，就要替换，服务器返回新的资源和新的资源标识。
这个标识就是Last-Modified 客户端返回的是Last-Modified-Since

还有e-tag 解决的是精度的问题，精确到秒以内
```





![image-20220521134922388](1. 计算机网络.assets/image-20220521134922388.png)



### 总结

```
1 缓存：如果一个资源就缓存，就可以不用再次发请求，能够更省力和方便

2 缓存分为强缓存和协商缓存
  强缓存：客户端发请求时，携带标识，和服务器的对比。如果在缓存时间里面，就使用原有的缓存。如果不在，服务器会返回新的资源
  有expires和cach-control
  expires是绝对时间 如果客户端本地时间修改了 就会不准
  cach-control是相对时间，如果出现了混乱，就会以cache-control为准。拿客户端本地的时间和相对的时间
  
  
  
  协商缓存：
  强缓存不能使用 进入协商缓存
  发送http请求 服务器通过请求头中的last-modified-since【last—modified】 和 if-NONE-MATCH[e-tag]检查资源是否更新
如果更新 返回200状态码和资源
  如果没有更新。返回304，告诉浏览器直接从缓存中拿资源
```





浏览器第一次请求：

第一次请求 没有缓存 发请求

![image-20220725142123723](D:/heima/front/5.%20vue/note/my_biji/5.4%20vue3/blog/blog20/lizhihang_learn/docs/5%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220725142123723.png)





后续的浏览器缓存

![image-20220725142157283](D:/heima/front/5.%20vue/note/my_biji/5.4%20vue3/blog/blog20/lizhihang_learn/docs/5%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220725142157283.png)





## 1.2 http中的keep-alive有什么作用

```diff
历史：
1 http1.0早期，默认每次请求应答，客户端和服务器连接的建立都要重新创建一个新的(短连接)
2 http1.1 规定了默认保持长连接 数据传输完成保持TCP连接不断开(长连接)，避免了后续建立或者重新建立连接

keep-alive建立过程：
1 客户端在向服务器发送请求报文时 在首部添加Connection字段
2 服务器收到请求 并处理Connection字段
3 服务器回送Connection：Keep-alive给客户端
4 客户端收到该字段
5 keep-alive建立成功

服务器自动断开过程：
1 客户端向服务器只发送请求报文 没有Connection
2 服务器收到请求并处理
3 服务器返回资源 关闭连接
4 客户端接受资源 发现没有Connection 断开连接

客户端断开连接的过程：
1 客户端向服务器发送Connection: close
2 服务器接受报文处理Connection字段
3 服务器返回资源
4 客户端接受资源 发现没有Connection 断开连接

优点：
1 减少CPU的占用和内存的消耗【不用建立新的连接】
2 减少了后续请求的延迟【无需握手】
3 降低拥塞的控制【tcp连接变少了】
4 报告错误的话无需关闭tcp连接

缺点：
1 本来可以释放的内存 结果一直释放不了 一直连接着也不合适

进步：
1 keep-alive: timeout=10 max=100
10s就过期
连接最多不超过100次就关闭
在timeout的有效时间里面，每次来一个请求，max就会减1
```



## 1.3 http2.x相较于http1.x的优势是什么

对于用户而言，速度提升非常非常非常的快

```js
1 传输数据的方式 二进制 而非文本格式 解析更加高效
2 头部压缩技术 减少传递重复的数据 降低网络的负担
3 采用服务器推送 主动向客户端推送资源，而不是等到浏览器解析的时候才发送
4 多路复用机制 减少需要创建的连接数量
```



`头部压缩`

http1.x请求和响应中会重复携带一些不常改变的数据

http2.x使用`首部表`来跟踪存储之前发送过的键值对。客户端和服务器共同来维护首部表【https 域名 get】只发送差异数据

![image-20220724161109805](D:/heima/front/5.%20vue/note/my_biji/5.4%20vue3/blog/blog20/lizhihang_learn/docs/5%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220724161109805.png)

·



`多路复用机制`

不用keep-alive了

http1.x如果要发送多个请求 必须使用多个多个TCP连接

- 为了控制资源，会对单个域名增加6-8个TCP连接的数量限制

但是http2.x：

- 同域名下的所有通信，都在单个连接行完成，
- 单个连接可以承担任意数量的双向数据流
- 数据流以消息的形式发送，而消息又以一个或者多个帧组成，帧的顺序可以是乱序[可以根据帧首部的流标识来进行组装]



#  

# 2. HTTPS

## 2.1 什么是HTTPS+为什么需要

```diff
HTTP传输，传输的报文都是明文的，很容易就被别人看到从传输的内容。

HTTPS是超文本传输安全协议，采用http进行信息的传输，多了的这个S，就是SSL/TLS，对信息进行加密、身份验证、完整性验证的功能。【但是SSL是TLS的前身。绝大多数浏览器现在支持的都是TLS】

通过加密保证安全
常见的加密算法：对称加密 非对称加密 hash算法
```

数据 -> http -> 安全层 -> tcp -> ip -> 数据链路层

安全层，对上面来的数据进行加密，对返回的数据进行解密

## 2.2 TLS/SLS的工作原理

### 对称加密

```diff
加密和解密用的是同一个密钥，比如双方约定，信息要倒着念才能够读懂.这个暗号.
是一对一


优点：
1 计算量小 加密速度快 加密效率高

缺点：
1 有可能“倒着念”这个方法中间被黑客截获了 => 一开始传输密钥的过程

应用：
1 本地数据加密 https 网络通信
常见的算法：
1 AES DES 3DES DESX Blowfish、IDEA、RC4、RC5、
RC6(全球公开, 通过了层层筛选, 层层检验)  没有被破解
2 经过公开检验 才是算安全 很多公开的算法 虽然可以用撞库的方式破解，但是成本很高
```





### 非对称加密

```js
1 概念：
有一对公钥和私钥。公钥是公开的，私钥是保密的。
用私钥加密的数据，只有用对应公钥才能够解密 => 签名
用公钥加密的数据，只有私钥才能够解密 => 加密数据
我们可以把公钥公布出去，任何想要和我们通信的用户 都可以使用公钥加密，只有我们才能够用私钥解密

2 优点： 安全
  缺点： 加密速度慢 只适合少量的数据，不然等待时间很长 跟非对称加密的算法有关系
  
3 如果一开始 公钥被中间人拿到，他本来就可以拿到 他也有一对公钥和私钥，发送给客户端，
客户端加密，中间人就可以用自己的私钥解密，再修改信息，用之前的公钥加密，发送给服务端
 

4 场景：
https会话前期
CA认证证书
信息加密
登录认证

5 常见算法：
RSA ECC(移动设备用) DSA(数字签名用)
```





### hash算法

```diff
MD5 SHA1 SHA256

根据一段内容 生成一段唯一的标识  用于验证数据是否被篡改，验证数据完整性
特点：
1 对输入非常的敏感
2 函数不可逆
3 输出的长度固定

中间人可以修改信息后重新计算摘要 所以需要对传输的信息和信息摘要进行加密

```







### `https加密的核心`

```diff
1 发送秘钥阶段 使用非对称加密的方法 发送方用公钥加密，接受方用私钥进行解密 => 得到对称加密的密钥
2 双方沟通时才使用对称加密的密钥
3 使用TLS/SSL	协议

非对称加密保证安全
对称加密保证便捷性
```







### 数字证书+数字签名

```js
一、现在不是完全安全 因为中间人可以截获对方发给我们的公钥，然后把自己的公钥发给我们。我们使用他的公钥加密信息，他能用自己的私钥解密。能够用同样的方法，去跟服务器进行沟通对话。


二、数字证书
是为了证明公钥是真实可靠权威的。
CA机构颁发数字证书，对你的网站的公钥、域名地址、证书到期时间加密，签发数字证书，保证网站的安全性。
当客户端收到消息，查看证书：
1看证书记载的网址，和现有的网址是否一致
2CA机构是否权威可靠
3证书一旦过期，浏览器也会发出警告

三、数字签名+数字证书
如果证书也被篡改了怎么办？
需要数字签名 => 能够根据数字签名的内容，生成一个唯一的标识


1 【hash算法】对【公钥+原始信息】加密生成一个 =》 信息摘要1
2 让有公信力的中心【CA】 用它的【私钥】对【信息摘要】进行加密，形成得到【签名】
3 【原始的信息】+【签名】 => 形成得到【数字证书】
---------------------------------------
4 接收方接到【数字证书】 => 使用同样的【hash算法】把【原始信息】加密 =》形成得到【生成一个摘要2】
5 用公证处的【公钥】对数字证书中的签名进行解密，解密得到【摘要1】
6 最后将解密的摘要1和生成的摘要2进行对比 判断信息是否被篡改



服务端向CA认证中心，申请SSL证书。
这里是SSL证书，原因是因为他的名气是更大的。

```

![image-20220724155321067](D:/heima/front/5.%20vue/note/my_biji/5.4%20vue3/blog/blog20/lizhihang_learn/docs/5%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220724155321067.png)









### SSL协议的握手总结

![image-20220308085627643](1. 计算机网络.assets/image-20220308085627643.png)



```diff
在服务器向CA申请了证书以后，会获得一对公钥和私钥。

1.客户端会向服务端发送自己支持的TLS版本，加密套件，和服务器生成的第一随机数。

2.服务端接收到了以后，会确认TLS版本，加密套件，自己也会生成第二个随机数发送给客户端

3.紧接着服务端还会发送自己的CA证书，公钥，并且 sever hello done的新号，表示打招呼完毕

4.第四，客户端收到了这些信息，会先拿服务端的CA证书和浏览器的证书列表进行比较，是否可以信任，如果可以，服务端会再次生成一个叫作预主密钥的东西，

5.这里开始用了加密，用服务端发送来的公钥进行预主密钥的加密。发送给服务器，并且告诉他，之后都用这个预主密钥生成新的密钥进行加密。

6.服务端收到了以后，用私钥解开得到预主密钥。这里是`非对称加密`

7.预主密钥只有双方自己知道，没有别人知道。各自用第一随机数 第二随机数 + 预主密钥生成会话密钥。

会话密钥的 =》 就是对称密钥的加密。
```





### 总结：

```diff
1. 为什么需要https?
   因为http是明文传输+信息公开不安全
   https在http基础上, 基于SSL/TSL协议，对信息加密
2. https是如何保证安全
   用非对称算法 加密 对称加密的密钥
   用对称密钥进行后续的沟通
   
   为什么前面要使用非对称加密的算法?
     非对称加密安全 =》能够一定程度上保障私钥的安全
   为什么后续不能使用非对称加密的密钥?
     因为计算机网络传输 信息量很大 => 耗费资源 + 非对称加密算法很慢 + 大树幂 大数算法
3. 这样也不一定安全，为什么？
   因为 公钥也有可能被进行伪造，中间人接受到信息
4. 我们可以用CA机构办法的证书 证明公钥是正规的
   看到证书：1 证书上的域名和我访问的域名是否一致 2 证书是否在有效期 3 CA机构是否是权威的
   
5. 如果证书也被篡改了？
   需要数字签名
   原始信息+公钥 hash加密 =》摘要1
   CA用私钥加密摘要1 =》数字签名
   数字签名+原始信息 =》数字证书
   ----
   接受方拿到数字证书
   把原始信息 =》hash =》摘要2
   用CA公钥解密数字签名=》摘要1
   摘要1和摘要2进行比较
6. 
   
```













# 3. TCP的三次握手和四次挥手

## 握手的前提条件

## 套接字socket

```diff
websocket套接字是什么?
1 类比：飞行飞行地点 - ip地址；管控中心[监控飞机状况的] - ip地址
  	   飞机的机长【第一第二机长都有自己的端口号】；管控中心的每个工作人员都有自己的端口号
  	   连接时需要ip地址+端口 就是套接字socket
2 打开谷歌和火狐访问b站
  一个电脑是一个客户端，同时打开两个应用进程，
  b站针对这两个进程建立连接
  浏览器会自动给火狐和谷歌分配ip和端口
  b站能够根据这两个分别建立连接
```











## 三次握手

![image-20220306193846491](1. 计算机网络.assets/image-20220306193846491.png)



```diff
1 websocket套接字是什么意思?

2 三次握手的前提？
    TCP连接有三个标识，SYN ACK FIN
    SYN表示同步
    ACK表示确认
    FIN表示结束
    
+    还会发送序列号，序列号有什么用？
    	1 作为初始值 是后续判断的依据 后续的确认号都是对方的序列号+1
    	2 能够区分开来哪些信息是不必要的，是累赘要舍弃的。服务端有序列号能够方式ddos攻击
+    什么是ddos攻击？为什么序列号能够防止ddos的攻击
		1 序列号能够避免一次性发送太多的信息 信息太多 但是没有序列号 就关闭
3 三次握手的核心三步
	1 想要和对方建立连接，客户端发送SYN+seq=x；
	2 服务端让对方知道自己收到信息 并且表示愿意建立连接
	  收到SYN标识+seq
	  服务端要发送 SYN ACK seq=y ack=x+1
	  ack确认号是对方的序列号+1
	3 客户端 让服务端知道自己收到了信息
	  发送 ACK，ack=y+1,seq=x+1
	  客户端根据对方发来的ack-1是否等于x判断是否是正确的信息
	 
	提示：第二步的确认号来自第一步的序列号+1；第二步的序列号自己生成；第三步的确认号来自第二步的序列号+1；第三步的序列号等于第二步的确认号 【不需要再次生成了】
4 三次握手的例子：
	1 机长 SYN + seq=8633 -》1
	2 管控中心生成 seq = y ,ack = 8633 + 1, SYN+ACK -》机长
	3 机长收到 ack - 1判断是否等于8633
	  ACK,seq = 8633+1,ack=y+1 -> 管控中心
	  
	男生追女神的例子：
	1 男生 我暗恋你 想要追你 你愿意跟我在一起吗 -》女神
	2 女神 我同意了，但是你确认嘛，想清楚了没呢 -》男生
	3 男生 我当然想清楚了，太好了 -》女神
	
	问题是，
	如果男生发消息给女神，女神因为一些事情太久没有回复了，让男生以为，女神对他不感冒，就走了，女神回了消息，就一直等着，苦苦的等着
+5 为什么需要三次握手？
	浏览器和服务器也是，如果浏览器发了消息，经过了很长时间，网络延迟，才发过去
	服务端收到了，也回复了
	但是浏览器因为等了太久没有回复，就先关闭了，
	此时服务器还在等着，就会浪费服务器的资源
	因此，三次握手的情况下，如果第三次没有进行，服务器就不会和该浏览器联立连接
```

![image-20220306195029158](1. 计算机网络.assets/image-20220306195029158.png)





## 四次挥手

![image-20220306195246690](1. 计算机网络.assets/image-20220306195246690.png)



```diff
1 三次握手后，发好了HTTP请求传输完毕，客户端和服务端都可以率先开始关闭通道 假设客户端先开始
四次挥手开始：
1 客户端想要断开连接，发送 ACK + FIN + seq1序列号1 + ack1确认号1 -》服务端
  此时的序列号1和确认号1不再是固定的数字 -》因为三次握手的过程中，序列号和确认号会不断的递增
2 服务端表示自己收到了消息，确认，要求等一等，看数据是否传输完毕
  服务端 ACK , ack确认号2=序列号1+1, seq2序号2=确认号1  -> 客户端 
3 服务端确认完毕，告知客户端可以关闭。
  ACK , FIN, ack2和seq2还是第二步的，因为此时客户端没有发消息来， 这里也就不用改变
4 客户端确认收到消息
  发送ACK , seq3=ack2, ack3 = seq2+1,
  客户端接到消息,直接把对方的确认号-1，就能够判断是否是正确的消息
5 结束 每个过程都是唯一，因为确认号和序列号不同

例子：
1 员工跟领导说我要下班啦
2 领导说，我知道了，但是你等一等，我看看活是否都干完了
3 领导确认后，告诉员工，活都干完了你可以走了
4 员工，收到消息，等了几秒，就走了
```





# 4. cookie session token 有什么区别

session：会发送到后台服务器。容量小4kb

5MB。

方法简单

localStorage：永久存储

sessionStorage: 短期当前会话。



# 5. 输入了url发生了什么【完整的http请求】

>负载均衡的概念：把操作任务 分发到不同的操作单元上面去执行。比入DNS负载均衡，具体是什么？

```diff
1.输入url按下回车后

2.查找当前url是否存在缓存，比较缓存是否过期了

- 如果资源没有缓存，向服务器发起请求
- 如果缓存了，检验是否足够新鲜，足够新鲜，直接提供给客户端，否则还是要进行服务器的验证
- 检验新鲜：
  1. expire HTTP1.0 提供的，一个绝对时间 表示缓存的新鲜日期
  2. cache-control: max-age 提供一个以秒为单位的最大新鲜时间 超过这个时间久不新鲜了

3.浏览器解析url 获取协议 主机 端口 path

- 浏览器还要组装请求报文
- 浏览器要获取主机的ip地址，如何获取？
  1. 浏览器缓存
  2. 本机的缓存
  3. hosts文件
  4. 路由器缓存
  5. ISP DNS缓存
  6. DNS递归查询 DNS域名解析

4.根据ip 打开一个socket与目标IP地址，端口建立TCP连接，这里需要知道具体的三次握手的流程

5.HTTP请求发起

6.服务器处理请求

- 检查客户端发来的请求报文，缓存是否过期，没过期，返回304状态码
- 处理好请求，准备HTTP响应，可能需要查询数据库的操作
- 将响应报文通过TCP连接发送给浏览器

7.浏览器接受响应，选择关闭TCP连接 四次挥手，还是说保留重用

在关闭之前
8.浏览器检查状态码，2开头的状态码和其他的状态码的处理情况不同

- 有哪里不同

9.如果资源可以缓存就缓存

10.对响应进行gzip压缩

11.根据资源类型，进行

构建dom树：
	1 tokenizing: 根据html规范将字符解析为标记
	2 Lexing: 词法分析将标记转换为对象并定义属性和规则
	3 DOM constructor： 根据HTML标记关系 将对象组成DOM树
解析过程中 遇到图片、样式表、js文件，自动下载
构建css树：
	1 tokinzing: 字符流转化为标记流
	2 Node：根据标记创建节点
	3 CSSOM：节点创建CSS树
根据dom树和css树构建渲染树：
	1 从DOM树的根节点 遍历所有可见节点 不可见节点包括 script meta这样本身不可见的标签 被css隐藏的标签 display: none
	2 对每一个可见节点找到恰当的cssom规则并应用
	3 发布可视节点的内容和计算样式
	
js解析过程：
	1 浏览器创建Document对象 解析HTML
	  解析到的元素和脚本添加到文档中
	  此时document.readystate为loading
	
	2 HTML解析器遇到没有async和defer的script时，将他们添加到文档中，
	  执行行内或者外部脚本，这些脚本会同步执行，并且在脚本下载和执行时，解析器会暂停
	  可以用document.write()把文本内容插入到输入流中
	  同步脚本经常简单定义函数和注册事件处理程序
	  他们可以遍历和操作script和他们之前的文档内容
	3 解析器遇到async和defer的script，开始下载脚本 继续解析文档
	  脚本会在他们下载完成后尽快执行
	  解析器不会停下来等它
	  异步脚本禁止使用document.write()
	  他们可以访问自己的script和之前的文档元素
	  
	4 文档解析完毕 document.readyState 变成interactive
	5 所有defer脚本会按照文档出现顺序执行
	  延迟脚本能访问完成的文档树
	  禁止使用document.write()
	6 浏览器在Document对象上触发DOMContentLoaded事件
	7 文档完全解析完毕
	  浏览器可能还在等待如图片等内容的加载
	  等到这些内容完全载入 并且所有异步脚本完成载入和执行
	  document.readState变为complete
	  window触发load事件



12.页面呈现
```



DNS是如何查找到ip地址的？

>域名查询 先DNS缓存 -> 根域名服务器 -> 下一级 递归查询后就找到了 给web服务器



为什么HTTP底层要基于TCP连接？

>TCP是端到端的可靠的面向连接的过程。
>
>如果数据传输错误，可以重传



浏览器如何对页面进行渲染的?
>1 解析html文件 构建dom树
>
>2 解析css文件 构建渲染树
>
>3 边解析 边渲染
>
>4 JS是单线程，会阻塞后续资源的下载。



# 6. cookie session JWT

https://www.bilibili.com/video/BV1ob4y1Y7Ep?spm_id_from=333.999.0.0

**==HTTP无状态:==**

第一次登录后，第二次再登录时，服务器无法确认我的身份，无法确认是我能够再次登录的。

那是怎么样做到免登录的呢?

存储功能。B站会把用户名和密码存储到数据库，下一次用户输入用户名和密码，就会去数据库查找是否有对应的，如果有，就返回相应的页面。

B站如何不让用户每次都输入用户名和密码呢?

**==cookie技术==**

用比喻来理解这三者是什么:

**cookie**

![image-20220320101642207](1. 计算机网络.assets/image-20220320101642207.png)

去超市买东西，想要优惠，需要会员卡，这个会员卡是没有实名的，这个是cookie。通过这个cookie，能够进入系统，从而进行价格的优惠结算。



**==具体过程==**

```
1. 客户端发送用户名和密码给服务器，
2. 服务器接受，利用setCookie方法，生成一个cookie，
3. 通过一个响应头，返回给客户端，
4. 客户端接受了，接受后，存储cookie在本地。
5. 下一次要发送请求，直接把cookie放到请求头，发送到服务端。
```

注意：

1.cookie存储在浏览器端

2.cookie能够直接在浏览器里查看，**非常不安全**。 就是浏览器里面的cookie信息是透明的，且是能够被伪造的。才有session技术的出现





==**session**==

session出现了，session在上面的例子中，就是让这个会员卡实名化了。去买鞋，买了以后，要不要办张会员卡，输入手机号和密码，办理成功了，你的姓名和手机号的身份信息都存储在他那里了。下一回，要再次使用的时候，直接你手机尾号是多少呀？我查一查有没有会员资质，这边一查，叫什么名字，都有了。

这就是session机制。



**==具体过程==**

```
1. 客户端发送用户名和密码给服务端，
2. 服务端接受，生成一个sessionId，而用户名和密码存储在服务器，需要内存存储，
3. 而这个sessionId通过响应头给到客户端，客户端接受到了接受。
4. 下一次访问，请求头里面放上**sessionId**，给服务器，
5. 服务器拿到后，根据id去查找对应的信息，查找到了，就返回给客户端。
```

注意点: 

 	1. 用户名和密码存储在服务器的，更加安全 
 	2. sessionId会被发送给客户端，是随机的，即使黑客拿到，意义不大，因为sessionId在被发送之前，是进行了数字签名的，黑客无法通过sessionId推断出用户名和密码

![image-20220320101230535](1. 计算机网络.assets/image-20220320101230535.png)



**token**

token就是一个身份令牌，身份证，有了它，能够有权限去做一些事情。访问一些接口和方法。

客户端 把用户名和密码，给到了服务器，服务器做数字签名，**并且加密**后得到**字符串作为token**，给客户端。

客户端拿到token，下次请求时，放到请求头的Authorization里面，服务端解密，签名认证，判断其有效性。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/29/16f523a04d9c745f~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)



**refresh token**

如果 access token【就是上面的token】过期了，有refresh token的话，能够刷新 获取新的access token。但是**refresh token**也过期了就不行

https://juejin.cn/post/6844904034181070861#heading-6





**JWT**

跨域流行的解决方案

是一种认证的授权机制



http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html





# 7. DNS域名解析过程

```js
1. DNS域名解析的过程和图书馆图书管理原理一致。
	找到一本书，先去图书馆的电脑检索。
        找到一串数字，这个数字是地址，表示了图书存储的位置。同样种类的书籍可能会被划分到一个区域，根据种类划分图书的位置，找书的时候，输入图书，只需要去找他的位置就可以了。
        这一串数字，I.12.138.1 I是一个区域，12是一个区域，138又是一块区域
        
        计算机，访问一个网站。网站其实是由IP地址来标明他的位置的，但是IP地址是纯数字或者是数字+字母，我们很难记住，因此需要域名，我们输入域名。
	www.bilibili.com
	www是主机名还有mail还是member 
        bilibili是B站 还有qq 
        .com又是更深的一层的，很多域名最终都是由.com来管理的
	.com由谁来管理的呢？
	.root，但是root没必要写，每个.com后面都是由root访问的，.也经常被我们忽略
```

![image-20220421230342055](1. 计算机网络.assets/image-20220421230342055.png)

根由13个根域名服务器进行管理，有1467个节点。绝大部分是重复的。客户端如何向与自己隔得最近的根域名服务器取得联系？通过`任播`的技术就能

- 根域名服务器管理顶级域名服务器 TLD
- 顶级域名服务器管理各自的权威域名服务器Authoritative

![image-20220421230529212](1. 计算机网络.assets/image-20220421230529212.png)



# 8. 常见网络报错

## 1. 状态码报500的情况

await userCheckAccount() 没有携带参数

报错还是这个

这样表示传参是有问题的

```js
    const result = await userCheckAccount({
      account: value
    })
```

也可以这样写，接口下面

```js
export const userCheckAccount = (account) => {
  return request('/register/check', 'get', { account }) // 能够带括号
}
```

传的时候 只传这个值

```js
const result = await userCheckAccount(value)
```



>1. 区分好传一个值还是传一个对象就行。
>
>2. 以及有可能没有带上参数，也报500“服务器内部错误”

## 2. 状态码报401的情况

返回token校验失败



可能是token过期

可能是token的请求拦截器 字段出错





## 3. 状态码报错400



对象不存在 - 把这个物品删除 重新加一个新的商品试试。可能其它接口给它改岔了





## 4. 400 错误 对象不存在

```diff
Error: Request failed with status code 400
```



```diff
export const deleteAddressApi = (form) => {
  return request(`/member/address/${form.id}`, 'delete')
}
```

传的是id，结果接口写的是form







