<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        /*
        手写call
        */

        Function.prototype.myBind = function (context) {
            // 1 判断调用的“东东”是不是函数 如果是其他 xxx.call() xxx不是函数 就会报错
            //   这里理解是不是有问题
            if (typeof context !== 'function') {
                return console.error('type error');
            }
            debugger
            // 2 为什么要保存当前函数的引用? 获取其余传入的参数
            let args = [...arguments].slice(1)
            // 3 保存当前函数的引用 比如这里是add函数
            let fn = this
            // 4 创建一个函数返回
            return function Fn() {
                debugger
                // 5 根据调用方式 传入不同的绑定值

                // 使用apply绑定调用fn函数 
                // 如果fn是构造函数，就把this给apply调用，
                // 如果不是，就把context传给fn执行

                // this指向 sub函数 
                return fn.apply(
                    this instanceof Fn ? this : context,
                    args.concat(...arguments)
                )
            }

        }

        function add(num1, num2) {
            console.log(this);
            debugger
            console.log(num1 + num2);
        }
        function sub(num1, num2) {
            console.log(num1 - num2);
        }
        add.myBind(sub)(6, 3)

        // let obj = {
        //     name: '123'
        // }
        // obj.myBind(sub)(55) // 这个会报错
    </script>
</body>

</html>