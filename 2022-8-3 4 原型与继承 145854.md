## 原型链







## 继承

### 1 为什么要继承？

人类的方法，就挂在到人类的原型对象上，所有的比如老师，学生，上班族，都直接用，无需重新挂载



### 2 原型链继承

假设声明Animal父类和Dog子类，目标是要求Dog能够继承Animal父类的方法和属性

最关键的一个步骤是，Dog.prototype = new Animal() 的实例

这样之后，new Dog实例，实例能够通过proto属性访问到Animal的实例自身的属性和方法，以及Animal的原型对象上面的方法

```js
        function Animal() {
            this.superType = 'animal'
            this.name = name || '动物'
            this.sleep = function () {
                console.log('sleep');
            }
        }
        Animal.prototype.eat = function (food) {
            console.log(this.name + '正在吃' + food);
        }
        function Dog(name) {
            this.name = name
        }
        // !关键
        Dog.prototype = new Animal()
        let doggie = new Dog('wangcai')
        console.log(doggie.superType); // animal =》自身
        doggie.sleep() // sleep =》原型
        doggie.eat('狗粮') // wangcai正在吃狗粮 =》自身
```



![image-20220803145847974](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4575/image-20220803145847974.png)

上图结合下图一起看，红色部分，doggie的proto指针指向Dog的原型对象。

而这个原型对象此时变为Animal的实例对象

因此Dog.prototype的指针发生了改变【上图】。doggie的指针也发生改变【下图】

![image-20220721130220008](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20220721130220008.png)



![image-20220721132127909](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20220721132127909.png)





关于Dog.prototype.constructor指向Animal构造函数，这样不好

我们改为Dog实例自身

```diff
        Dog.prototype = new Animal()
+        Dog.prototype.constructor = Dog
        let doggie = new Dog('wangcai')
        console.log(doggie.superType); // animal
        doggie.sleep() // sleep
        doggie.eat('狗粮') // wangcai正在吃狗粮

```



原型链继承的缺点：

1 子类创建的实例无法向父类去传参

2 如果父类的一个数据是引用数据类型，子类1修改了，会影响其它子类2 子类3的值。因为他们共享父类里面的值，特别还是引用数据类型

```js
        function Person() {
            this.emotion = ['吃饭', '睡觉']
        }
        function Student(id) {
            this.id = id
        }
        Student.prototype = new Person()
        Student.prototype.constructor = Student
        let stu1 = new Student('123')
        console.log(stu1.emotion); // ['吃饭','睡觉']
        stu1.emotion.push('学习')
        let stu2 = new Student('34')
        console.log(stu2.emotion); // ['吃饭','睡觉','学习']
```

3 子类挂载的方法，如果在改造原型链之前会被覆盖

```diff
        function Person() {
            this.emotion = ['吃饭', '睡觉']
        }
        function Student(id) {
            this.id = id
        }
+        Student.prototype.study = function () {
            console.log('好好学习');
        }
        Student.prototype = new Person()
        Student.prototype.constructor = Student
+        Student.prototype.study = function () {
            console.log('好好学习');
        } // 写在这里就没事
        let stu1 = new Student('123')
        console.log(stu1.emotion); // ['吃饭','睡觉']
        stu1.emotion.push('学习')
        let stu2 = new Student('34')
        console.log(stu2.emotion); // ['吃饭','睡觉','学习']
+        console.log(stu1 === stu2) // true
        stu1.study()
```



4 记住 原型链继承 让子类的原型对象 = new 父类的实例 ，

```js
        Student.prototype = new Person() // 正确
        Student.prototype = Person.prototype // 错误
```

后者无法访问内部的属性，只能访问到原型



### 3 构造函数继承



关键代码，在子类内部使用call方法或者apply方法调用Person类，改变this

这里的this指向谁？指向新创建的Student实例对象，分别为stu1和stu2，

也让Person里面的this指向实例对象 因此打印stu1和stu2里面都有emotion和age

```diff
        function Person(age) {
            this.emotion = ['吃饭', '睡觉']
            this.age = age
        }
        function Student(id, age) {
+           Person.call(this, age)
            this.id = id
        }

        let stu1 = new Student('001', 19)
        console.log(stu1);
        // stu1.emotion.push('打豆豆')
        let stu2 = new Student('002', 20)
        console.log(stu2); 
```



优点：

1 两个子类 其中一个子类修改了父类里面的引用数据类型的值 不会影响另一个子类里面的变量的数据，下面stu1里面有打豆豆，stu2里面没有打豆豆

为什么？

```diff
        function Person(age) {
            this.emotion = ['吃饭', '睡觉']
            this.age = age
        }
        function Student(id, age) {
            Person.call(this, age)
            this.id = id
        }

        let stu1 = new Student('001', 19)
        console.log(stu1);
+        stu1.emotion.push('打豆豆')
        let stu2 = new Student('002', 20)
        console.log(stu2); 
```



>为什么构造函数子类的数据不会互相影响。原型链会互相影响

对比原型链继承和构造函数继承，打印两个实例里面的emotion，构造函数的是相等的，原型链继承是不相等的。原因是，构造函数继承，是改变父类的this指向，会new 新的实例，开辟新的内存空间。而原型链继承，他们new出的实例 指向的是同一块地方，就会互相影响

![image-20220721132127909](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20220721132127909.png)





2 优点2，子类可以往父类里面传递参数，上面的19和20传递给age，

age给到Person.call(this, age)这里的age，再给到Person这个类





缺点：

1 父类挂载的原型方法 子类访问不到，为什么？

因为是通过函数调用的方式，让父类的this指向了实例对象，但是原型链没有被修改。

因此子类的实例，通过proto属性只能够访问到子类的原型 对象，访问不到父类的原型对象

```diff
        function Person(age) {
            this.emotion = ['吃饭', '睡觉']
            this.age = age
        }
+       Person.prototype.sayHi = function () {
            console.log(1);
        }
        function Student(id, age) {
            Person.call(this, age)
            this.id = id
        }

        let stu1 = new Student('001', 19)
        console.log(stu1);
        stu1.emotion.push('打豆豆')
        let stu2 = new Student('002', 20)
        console.log(stu1.emotion === stu2.emotion); // false
        console.log(stu2);
+        stu1.sayHi() // 报错 
```



2 由第一个缺点，带来，方法不能挂载到原型对象，只能放到父类本身。每次创建一个实例，都会创建一个方法，容易造成内存浪费





### 4 拷贝继承

父构造函数 + 子构造函数

子构造函数里面，new 一个父构造函数实例，

for …… in遍历实例里面的方法，要判断是原型的还是自身拥有的，

```diff
		// 拷贝继承
        // 实现方式+优点+缺点
        function Person(age) {
            this.age = age
            this.emotion = ['吃饭', '睡觉', '打豆豆']
        }
        Person.prototype.run = function () {
+           console.log(this.id + '正在跑步' + this.age);
        }

        function Student(id, age) {
            this.id = id
+            // 能够给父类传递参数
+            let person = new Person(age)
            for (let key in person) {
+                if (person.hasOwnProperty(key)) {
                    // !这里怎么写 存在疑惑
                    // 返回false 表示该方法是原型的不是自己的
                    // 如果是自己id 返回true
+                    this[key] = person[key]
                } else {
                // 原型方法 直接给Student挂载
+                    Student.prototype[key] = person[key]
                }
            }
        }
        Student.prototype.eat = function () {
            console.log(this.id + '正在吃饭' + this.age);
        }
        let stu1 = new Student('1001', 19)
        stu1.eat()
        stu1.run()
        console.log(stu1);
```



优点：

- 能够继承父类里面所有的属性和方法，包括`原型对象上的`
- 能够给父类传递参数



缺点：

- 父类里面所有的方法都会拿过来 浪费内存





### 5. 组合继承

```diff
		function Person(age) {
            this.age = age
            this.emotion = ['吃饭', '睡觉', '打豆豆']
        }
        Person.prototype.run = function () {
            console.log(this.id + '正在跑步' + this.age);
        }

        function Student(id, age) {
+            Person.call(this, age)
            this.id = id
        }
+        Student.prototype = new Person()
+        Student.prototype.constructor = Student
        Student.prototype.eat = function () {
            console.log(this.id + '正在吃饭' + this.age);
        }
        let stu2 = new Student('1001', 21)
        console.log(stu2.emotion);
        stu2.run()
        stu2.eat()
```



![image-20220722203608768](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20220722203608768.png)



优点：

- 能够传参给父类【这是构造函数继承的优点 原型链继承做不到的】
- 能够使用父类原型上面的方法【这是原型链继承的优点 构造函数继承做不到的】

缺点：

- 父类的构造函数被执行了两次
  - 第一次在`Person.call()`
  - 第二次在`    Student.prototype = new Person()`
- 【没搞懂】的Person.prototype的方法和父类自身的方法重名，子类只能够使用父类里面的方法，使用不到原型链上面的方法【先放着】

![image-20220722204036170](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20220722204036170.png)





### 6. 寄生组合继承

子类的原型对象 不 直接指向父类对象new出来的实例，而是

预先创建一个新的空的构造函数，让他的原型对象等于父类的原型对象，

再让子类的原型对象 直接等于 新的构造函数new出来的实例



也可以用

里面指向new Person()也可以

```js
Super.prototype = Object.create(Person.prototype)
```

```diff
function Person(age) {
            this.age = age
            this.emotion = ['吃饭', '睡觉', '打豆豆']
            this.study = function () {
                console.log(this.id + '正在学习');
            }
        }
        Person.prototype.run = function () {
            console.log(this.id + '正在跑步' + this.age);
        }

        Person.prototype.study = function () {
            console.log(this.id);
        }
        function Student(id, age) {
            Person.call(this, age)
            this.id = id
        }
+        function Super() {}
		// Super.prototype = Object.create(Person.prototype)
        Super.prototype = Person.prototype
        // 不再new Person() 不让Person() 这个实例对象里面的变量和方法被绑定两次
        Student.prototype = new Super()
        Student.prototype.constructor = Student
        Student.prototype.eat = function () {
            console.log(this.id + '正在吃饭' + this.age);
        }
        let stu2 = new Student('1001', 21)
        console.log(stu2.emotion);
        stu2.run()
        stu2.eat()
```





思考，等于父类的原型对象为什么也可以，因为父类的属性和方法【非原型】，通过

```diff
		function Person() {
            this.emotion = ['吃饭', '睡觉']
        }
        Person.prototype.sing = function () {
            console.log('I can sing');
        }
        function Student(id) {
            this.id = id
        }
        Student.prototype.study = function () {
            console.log('好好学习');
        }
        // 原本是 Student.prototype = new Person()
+        Student.prototype = Person.prototype
        Student.prototype.constructor = Student
        let stu1 = new Student('123')
        console.log(stu1.emotion); // ['吃饭','睡觉']
        stu1.emotion.push('学习')
```

这样的导致，无法访问Person内部的实例对象，只能够访问原型对象上面的方法



为什么通过一个新的构造函数，就可以了呢?

有点问题





### 7. class类继承

- 使用super关键字能够实现继承，如果要执行父类构造函数传递参数，子类使用的super必须传递参数

super(name, age)

- 可以直接使用super.say()来访问父类的方法
- super必须在子类的this之前访问

```diff
		class Father {
            constructor(name, age) {
                this.name = name
                this.age = age
            }
            say() {
                console.log('我是爸爸');
                return '我是爸爸'
            }
        }
        class Son extends Father {
            constructor(name, age, lesson) {
+                super(name, age)
                this.lesson = lesson
            }
            sleep() {
+                console.log(super.say() + '的儿子');
            }
        }
        let son1 = new Son('18', 19, 100)
        son1.sleep()
        console.log(son1);	
```

