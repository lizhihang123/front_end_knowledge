

<!-- :::important
:::note
:::tip
:::caution
:::warning -->



### 2.1 原型链

1 为什么要有原型

2 原型是什么 构造函数 实例对象 原型对象的三角关系

3 原型链的查找原则 举例



#### 1 为什么需要

声明2个实例，每个实例都会独立创建sayHi方法，非常占用内存。一样的方法，可以放在原型对象上共用。

```js
        function Person(name, age) {
            this.name = name
            this.age = age
            this.sayHi = () => {
                console.log(1);
            }
        }
        let p1 = new Person('ls', '19')
        let p2 = new Person('zs', 20)
        console.log(p1.sayHi === p2.sayHi); // false
        p1.sayHi()
        p2.sayHi()
```



#### 2 三角关系

![image-20220721103018637](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20220721103018637.png)

`注意点`

```diff
每一个原型对象身上 都有一个constructor属性能够指向他对应的构造函数
1 每一个构造函数能够new一个实例，创建一个实例对象
  每一个构造函数身上都有一个prototype能够指向他的原型对象 且
  只有函数有prototype属性，实例对象 但不是函数 就没有
2 每个实例对象身上都有proto属性，指向该实例对象 对应的构造函数的原型对象
3 原型对象也有proto属性，指向父节点的prototype，就是Object.prototype?
4 function Object和 function Function也是构造函数Function的实例对象， 他们俩都有proto属性指向Function.prototype
```





#### 3 查找原则

最终的是实例对象的proto属性，当他调用属性和方法时，会先从自身去查找，如果找到就用。找不到就通过proto属性去原型对象上找。直到找到Object.prototype上，如果还没有，就报错。

`__proto__的走向`



`性能`：

查找的链路越长，对性能的影响就会越大



#### 4 我可能表单能力不是特别好

#### 5 hasOwnProperty

```diff
        function Person(name, age) {
            this.name = name
            this.age = age
            this.sayHi = () => {
                console.log(1);
            }
        }
        let p1 = new Person('ls', '19')
        let p2 = new Person('zs', 20)
        console.log(p1.sayHi === p2.sayHi); // false
        p1.sayHi()
        p2.sayHi()
+        console.log(p1.hasOwnProperty('name')); // true
+        console.log(p1.hasOwnProperty('age')); // true
+        console.log(p1.hasOwnProperty('hasOwnProperty')); // false
```

`hasOwnProperty`是Object的()的方法，

这个方法老是记混，如果这个方法是自己的，`Own`，就是true，如果是原型的，不是自己的，就返回false



封装方法，如果是原型的，就返回true

```js
function hasProtoTypeProperty(object, property) {
    debugger
    return !object.hasOwnProperty(property) && (property in object)
}
console.log(hasProtoTypeProperty(p1, 'age')); // true =》表示 age属性是原型的
console.log(hasProtoTypeProperty(p1, 'name')); // false =》表示 name属性不是原型
```





#### 6 原型挂载更多方法

```js
        Person.prototype = {
+            constructor: Person, // 防止走丢 因为赋值为一个新对象
            show() {
                console.log('1');
            },
            hide() {
                console.log(2);
            }
        }
        let p1 = new Person('xiaohangge')
        p1.show()
        p1.hide()
```



#### 7 访问对象属性几种方法

```js
6. 
访问对象身上属性的几种情况：
- 通过Object.keys ['name'] 无法获取不可枚举属性 和 原型链上继承的属性
- 通过Object.getOwnPropertyNames(stu) 原型链上继承的属性访问不到 只能访问自身的 不可枚举的可以访问的到 z正好和名字类似，getOwnPropertyNames
- 通过for in 无法获取 不可枚举的属性 因为for in就是遍历“能够迭代”的可以读的属性
```



```js
function Student(name, age) {
    this.name = 'Kwu'
}
Student.prototype = {
    job: 'student'
}
let stu = new Student()
Object.defineProperty(stu, 'age', {
    value: '19',
    enumerable: false
})

console.log(stu.name); // Kwu
console.log(stu.job); // student
console.log(stu.age); // 19

console.log(Object.getOwnPropertyNames(stu)); // 原型链上继承的属性访问不到 只能访问自身的 不可枚举的可以访问的到
console.log(Object.keys(stu)); // ['name'] 无法获取不可枚举属性 和 原型链上继承的属性
// for in 无法获取 不可枚举的属性
for (let pro in stu) {
    console.log(pro); // name job
}
```



#### 8. 如何判断属性实例属性 并且是可以枚举的

`propertyIsEnumerable()`

原型上的，返回false

属性不存在，返回false

不可枚举的，返回false

```js
function Hobby(hobby) {
    this.hobby = hobby
}
Hobby.prototype.sayHello = function () {
    console.log('你好');
}
Hobby.prototype.height = 180
let stu1 = new Hobby('吃饭')
console.log(stu1.propertyIsEnumerable('hobby')); // true
console.log(stu1.propertyIsEnumerable('height')); // false 原型上的属性不行
console.log(stu1.propertyIsEnumerable('age')); // false 不存在该属性 就是返回 false
Object.defineProperty(stu1, 'hobby', {
    enumerable: false
})
console.log(stu1.propertyIsEnumerable('hobby')); // false 设置为不可以枚举了
```



#### 9.小结：

1. for in: 如果属性不可以枚举,enumerale：false； 那么for in 访问不到
2. Object.keys['names']，如果属性是自身实例，ok。其他都不行
3. Object.getOwnPropertyNames(name) 除了原型链上继承的不能访问，其余的都能够访问
4. stu1.propertyIsEnumerable('属性名') 能够判断 属性是否是对象实例自身的，并且是可以枚举的。都满足，才是true









### 2.2 Object.create()

```js
1. 创建一个对象
2. 该对象的实例属性和原型被指定
const obj = Object.create(prototype, propertyDescriptor)
3. prototype可以为null【但必须有一个值】，如果为null,obj的原型为`undefined`
```



下面得出，stu1的__proto__指向为obj

```js
const obj = {
    name: 'lizhihang',
    age: '123'
}
const stu1 = Object.create(obj)
console.log(stu1.name); // lizhihang
console.log(stu1.age); // 123
console.log(stu1.__proto__ === obj); // true
```



第二个参数指定，使用

```js
const person = Object.create(null, {
    username: {
        value: 'xiaohangzai',
        enumerable: true,
        writable: true,
        configurable: true
    },
    age: {
        value: '19',
    }
})
console.log(person.username); // xiaohangzai
console.log(person.age); // 19 可以访问
for (let o in person) {
    console.log(o); // 只有username // 因为 enumerable默认是false
}
person.age = 27
console.log(person.age); // 仍旧是19 因为 writable属性默认是false
delete person.age
console.log(person.age); // 19 仍旧存在 没有能够删除的 因为 configurable就是true
```



### 手写

```js
Object.create = function (proto, propertiesObject) {
    // 1. 创建一个构造函数
    function F() { }
    // 2. 构造函数的prototype指向新传递进来的参数 proto属性
    F.prototype = proto;
    // 3. 判断是否有第二个参数【这一步没能实现成功 Object.create()的第二个参数可以给最终的对象增加很多属性，但是我没加成功】
    if (propertiesObject) { Object.defineProperties(F, propertiesObject) }
    // 4. 创建一个新的实例对象 并return
    var f = new F()
    return f
}
var obj = {
    name: 'lizhihang',
    height: 180
}
const obj1 = Object.create(obj, {
    age: {
        value: '18',
        enumerable: true,
        writable: true,
        configurable: true
    }
})
console.log(obj1); // 其实是一个空对象
console.log(obj1.name); // obj1 能够访问到 obj身上的 lizhihang
console.log(obj1.height); // 180
console.log(obj1.age); // 180
console.log(obj1.__proto__ === obj); // true
```





### 场景

```js
// 1. 实现继承2 
function Person(name, age) {
    this.name = name
    this.age = age
}
Person.prototype.getInfo = function () {
    console.log('getInfo', this.name, this.age, this.height);
}
function Student(name, age, height) {
    // 1. 能够共享父类里面的属性和方法
    Person.call(this, name, age)
    this.height = height
}
// 2. 能够共享父类 原型上面的方法
Student.prototype = Object.create(Person.prototype)
// 3. 
let person2 = new Student('lizhihang', 19, 180)
console.log(person2.__proto__); // 原本应该指向 Student构造函数的prototype 因为Student.prototype = Object.create(Person.prototype)
// 所以 person2.__proto__指向Person的类
console.log(Student.prototype.constructor); // 指向Person 这是不合理的 我们应该修改过来
Student.prototype.constructor = Person
console.log(person2.name); // lizhihang
console.log(person2.age); // 19
// 子类的实例对象上面找不到 会去父类上面找
console.log(person2.getInfo()); // lizhihang 19 180
```









# 继承

### 1 为什么要继承？

人类的方法，就挂在到人类的原型对象上，所有的比如老师，学生，上班族，都直接用，无需重新挂载



### 2 原型链继承

假设声明Animal父类和Dog子类，目标是要求Dog能够继承Animal父类的方法和属性

最关键的一个步骤是，Dog.prototype = new Animal() 的实例

这样之后，new Dog实例，实例能够通过proto属性访问到Animal的实例自身的属性和方法，以及Animal的原型对象上面的方法

```js
        function Animal() {
            this.superType = 'animal'
            this.name = name || '动物'
            this.sleep = function () {
                console.log('sleep');
            }
        }
        Animal.prototype.eat = function (food) {
            console.log(this.name + '正在吃' + food);
        }
        function Dog(name) {
            this.name = name
        }
        // !关键
        Dog.prototype = new Animal()
        let doggie = new Dog('wangcai')
        console.log(doggie.superType); // animal =》自身
        doggie.sleep() // sleep =》原型
        doggie.eat('狗粮') // wangcai正在吃狗粮 =》自身
```



上图结合下图一起看，红色部分，doggie的proto指针指向Dog的原型对象。

而这个原型对象此时变为Animal的实例对象

因此Dog.prototype的指针发生了改变【上图】。doggie的指针也发生改变【下图】

![image-20220814201824577](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4575/image-20220814201824577.png)





<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4575/image-20220814201846037.png" alt="image-20220814201846037" style="zoom: 33%;" />





关于Dog.prototype.constructor指向Animal构造函数，这样不好

我们改为Dog实例自身

```diff
        Dog.prototype = new Animal()
+        Dog.prototype.constructor = Dog
        let doggie = new Dog('wangcai')
        console.log(doggie.superType); // animal
        doggie.sleep() // sleep
        doggie.eat('狗粮') // wangcai正在吃狗粮

```



原型链继承的缺点：

1 子类创建的实例无法向父类去传参

2 如果父类的一个数据是引用数据类型，子类1修改了，会影响其它子类2 子类3的值。因为他们共享父类里面的值，特别还是引用数据类型

```js
        function Person() {
            this.emotion = ['吃饭', '睡觉']
        }
        function Student(id) {
            this.id = id
        }
        Student.prototype = new Person()
        Student.prototype.constructor = Student
        let stu1 = new Student('123')
        console.log(stu1.emotion); // ['吃饭','睡觉']
        stu1.emotion.push('学习')
        let stu2 = new Student('34')
        console.log(stu2.emotion); // ['吃饭','睡觉','学习']
```

3 子类挂载的方法，如果在改造原型链之前会被覆盖

```diff
        function Person() {
            this.emotion = ['吃饭', '睡觉']
        }
        function Student(id) {
            this.id = id
        }
+        Student.prototype.study = function () {
            console.log('好好学习');
        }
        Student.prototype = new Person()
        Student.prototype.constructor = Student
+        Student.prototype.study = function () {
            console.log('好好学习');
        } // 写在这里就没事
        let stu1 = new Student('123')
        console.log(stu1.emotion); // ['吃饭','睡觉']
        stu1.emotion.push('学习')
        let stu2 = new Student('34')
        console.log(stu2.emotion); // ['吃饭','睡觉','学习']
+        console.log(stu1 === stu2) // true
        stu1.study()
```



4 记住 原型链继承 让子类的原型对象 = new 父类的实例 ，

```js
        Student.prototype = new Person() // 正确
        Student.prototype = Person.prototype // 错误
```

后者无法访问内部的属性，只能访问到原型



### 3 构造函数继承



关键代码，在子类内部使用call方法或者apply方法调用Person类，改变this

这里的this指向谁？指向新创建的Student实例对象，分别为stu1和stu2，

也让Person里面的this指向实例对象 因此打印stu1和stu2里面都有emotion和age

```diff
        function Person(age) {
            this.emotion = ['吃饭', '睡觉']
            this.age = age
        }
        function Student(id, age) {
+           Person.call(this, age)
            this.id = id
        }

        let stu1 = new Student('001', 19)
        console.log(stu1);
        // stu1.emotion.push('打豆豆')
        let stu2 = new Student('002', 20)
        console.log(stu2); 
```



优点：

1 两个子类 其中一个子类修改了父类里面的引用数据类型的值 不会影响另一个子类里面的变量的数据，下面stu1里面有打豆豆，stu2里面没有打豆豆

为什么？

```diff
        function Person(age) {
            this.emotion = ['吃饭', '睡觉']
            this.age = age
        }
        function Student(id, age) {
            Person.call(this, age)
            this.id = id
        }

        let stu1 = new Student('001', 19)
        console.log(stu1);
+        stu1.emotion.push('打豆豆')
        let stu2 = new Student('002', 20)
        console.log(stu2); 
```



>为什么构造函数子类的数据不会互相影响。原型链会互相影响

对比原型链继承和构造函数继承，打印两个实例里面的emotion，构造函数的是相等的，原型链继承是不相等的。原因是，构造函数继承，是改变父类的this指向，会new 新的实例，开辟新的内存空间。而原型链继承，他们new出的实例 指向的是同一块地方，就会互相影响



![image-20220814201918229](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4575/image-20220814201918229.png)





2 优点2，子类可以往父类里面传递参数，上面的19和20传递给age，

age给到Person.call(this, age)这里的age，再给到Person这个类





缺点：

1 父类挂载的原型方法 子类访问不到，为什么？

因为是通过函数调用的方式，让父类的this指向了实例对象，但是原型链没有被修改。

因此子类的实例，通过proto属性只能够访问到子类的原型 对象，访问不到父类的原型对象

```diff
        function Person(age) {
            this.emotion = ['吃饭', '睡觉']
            this.age = age
        }
+       Person.prototype.sayHi = function () {
            console.log(1);
        }
        function Student(id, age) {
            Person.call(this, age)
            this.id = id
        }

        let stu1 = new Student('001', 19)
        console.log(stu1);
        stu1.emotion.push('打豆豆')
        let stu2 = new Student('002', 20)
        console.log(stu1.emotion === stu2.emotion); // false
        console.log(stu2);
+        stu1.sayHi() // 报错 
```



2 由第一个缺点，带来，方法不能挂载到原型对象，只能放到父类本身。每次创建一个实例，都会创建一个方法，容易造成内存浪费





### 4 拷贝继承

父构造函数 + 子构造函数

子构造函数里面，new 一个父构造函数实例，

for …… in遍历实例里面的方法，要判断是原型的还是自身拥有的，

```diff
		// 拷贝继承
        // 实现方式+优点+缺点
        function Person(age) {
            this.age = age
            this.emotion = ['吃饭', '睡觉', '打豆豆']
        }
        Person.prototype.run = function () {
+           console.log(this.id + '正在跑步' + this.age);
        }

        function Student(id, age) {
            this.id = id
+            // 能够给父类传递参数
+            let person = new Person(age)
            for (let key in person) {
+                if (person.hasOwnProperty(key)) {
                    // !这里怎么写 存在疑惑
                    // 返回false 表示该方法是原型的不是自己的
                    // 如果是自己id 返回true
+                    this[key] = person[key]
                } else {
                // 原型方法 直接给Student挂载
+                    Student.prototype[key] = person[key]
                }
            }
        }
        Student.prototype.eat = function () {
            console.log(this.id + '正在吃饭' + this.age);
        }
        let stu1 = new Student('1001', 19)
        stu1.eat()
        stu1.run()
        console.log(stu1);
```



优点：

- 能够继承父类里面所有的属性和方法，包括`原型对象上的`
- 能够给父类传递参数



缺点：

- 父类里面所有的方法都会拿过来 浪费内存





### 5. 组合继承

```diff
		function Person(age) {
            this.age = age
            this.emotion = ['吃饭', '睡觉', '打豆豆']
        }
        Person.prototype.run = function () {
            console.log(this.id + '正在跑步' + this.age);
        }

        function Student(id, age) {
+            Person.call(this, age)
            this.id = id
        }
+        Student.prototype = new Person()
+        Student.prototype.constructor = Student
        Student.prototype.eat = function () {
            console.log(this.id + '正在吃饭' + this.age);
        }
        let stu2 = new Student('1001', 21)
        console.log(stu2.emotion);
        stu2.run()
        stu2.eat()
```



![image-20220722203608768](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4575/image-20220722203608768.png)



优点：

- 能够传参给父类【这是构造函数继承的优点 原型链继承做不到的】
- 能够使用父类原型上面的方法【这是原型链继承的优点 构造函数继承做不到的】

缺点：

- 父类的构造函数被执行了两次
  - 第一次在`Person.call()`
  - 第二次在`    Student.prototype = new Person()`
- 【没搞懂】的Person.prototype的方法和父类自身的方法重名，子类只能够使用父类里面的方法，使用不到原型链上面的方法【先放着】

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4575/image-20220814201933980.png" alt="image-20220814201933980" style="zoom:50%;" />





### 6. 寄生组合继承

子类的原型对象 不 直接指向父类对象new出来的实例，而是

预先创建一个新的空的构造函数，让他的原型对象等于父类的原型对象，

再让子类的原型对象 直接等于 新的构造函数new出来的实例



也可以用

里面指向new Person()也可以

```js
Super.prototype = Object.create(Person.prototype)
```

```diff
function Person(age) {
            this.age = age
            this.emotion = ['吃饭', '睡觉', '打豆豆']
            this.study = function () {
                console.log(this.id + '正在学习');
            }
        }
        Person.prototype.run = function () {
            console.log(this.id + '正在跑步' + this.age);
        }

        Person.prototype.study = function () {
            console.log(this.id);
        }
        function Student(id, age) {
            Person.call(this, age)
            this.id = id
        }
+        function Super() {}
		// Super.prototype = Object.create(Person.prototype)
        Super.prototype = Person.prototype
        // 不再new Person() 不让Person() 这个实例对象里面的变量和方法被绑定两次
        Student.prototype = new Super()
        Student.prototype.constructor = Student
        Student.prototype.eat = function () {
            console.log(this.id + '正在吃饭' + this.age);
        }
        let stu2 = new Student('1001', 21)
        console.log(stu2.emotion);
        stu2.run()
        stu2.eat()
```





思考，等于父类的原型对象为什么也可以，因为父类的属性和方法【非原型】，通过

```diff
		function Person() {
            this.emotion = ['吃饭', '睡觉']
        }
        Person.prototype.sing = function () {
            console.log('I can sing');
        }
        function Student(id) {
            this.id = id
        }
        Student.prototype.study = function () {
            console.log('好好学习');
        }
        // 原本是 Student.prototype = new Person()
+        Student.prototype = Person.prototype
        Student.prototype.constructor = Student
        let stu1 = new Student('123')
        console.log(stu1.emotion); // ['吃饭','睡觉']
        stu1.emotion.push('学习')
```

这样的导致，无法访问Person内部的实例对象，只能够访问原型对象上面的方法



为什么通过一个新的构造函数，就可以了呢?

有点问题





### 7. class类继承

- 使用super关键字能够实现继承，如果要执行父类构造函数传递参数，子类使用的super必须传递参数

super(name, age)

- 可以直接使用super.say()来访问父类的方法
- super必须在子类的this之前访问

```diff
		class Father {
            constructor(name, age) {
                this.name = name
                this.age = age
            }
            say() {
                console.log('我是爸爸');
                return '我是爸爸'
            }
        }
        class Son extends Father {
            constructor(name, age, lesson) {
+                super(name, age)
                this.lesson = lesson
            }
            sleep() {
+                console.log(super.say() + '的儿子');
            }
        }
        let son1 = new Son('18', 19, 100)
        son1.sleep()
        console.log(son1);	
```











### 2.1 箭头函数使用说明 

【6-14】【6-18】【6-20】

```diff
1. 如果只有一个参数，参数的小括号可以省略

2. 如果只有一个语句，花括号{}可以省略

3. 如果没有参数，() 不能够省略

4. 箭头函数返回一个对象，不能直接 () => {} ，这样{}会被解析为一个函数体；应该是 () => ({})；
或者是() => {return {}}

5. 箭头函数的this指向的是父级作用域所在的上下文，箭头函数不会创建自己的this。
他的作用域和使用的位置没有关系。他的this指向，取决于定义位置父级的上下文

5.1 且箭头函数没有this -> 不能够被new 调用

6. 箭头函数不能通过 call() apply() bind() 直接修改他的this指向，但是可以传递形参。
【会默认忽略第一个参数】

7. 箭头函数不适用的场景还有
- 箭头函数是匿名函数，不能用作构造函数 let Person = () => {}; let person = new Person() 这样会报错
- 箭头函数没有prototype属性 let fun = () => {}； 直接 fun.prototype 是undefined;

8. 箭头函数内部没有arguments 如果要同时获取多个参数
       const A2 = (...a) => {
            // console.log(arguments);  // undefined
            console.log(a); 
        }
```





代码验证

```js
// 1. 普通函数 this指向的一个坑
        let obj3 = {
            a: {
                fn: function() {
                    console.log(this);
                },
                b: 10
            }
        }
        obj3.a.fn() // 指向调用者 a对象
        let temp = obj3.a.fn
        temp() // 函数调用模式 指向window
// 我第一次认为temp() this指向的是调用者 a对象 结果是window 函数调用方式 就是window


// 2. 构造函数和原型对象上挂载的函数的this指向 都是 new创建的新实例
        function Person(theName, theAge) {
            this.name = theName // 指向创建的实例
            this.age = theAge
        }
        Person.prototype.sayHello = function () {
            console.log(this); // 指向创建的实例
            console.log('大家好, 我是' + this.name + ', 我今年' + this.age);
        }
        let per = new Person('小黑', 18) 
        per.sayHello()

// 3. 箭头函数其实是匿名函数 不能使用new
        let fn1 = () => {
            console.log('不能使用new');
        }
        // var first = new fn1() //  fn1 is not a constructor
// 3.1 箭头函数的this指向
        // 注意，var 声明的变量会被绑定到window上面，let和const声明的全局变量不会，
        // 而是绑定到script上面 见下面这张图
        // 如果是函数内部，let const var 变量都是绑定到Local上面 没有差别
        var name1 = 100
        let obj = {
            name1: 200,
            foo: function() {
                console.log(this.name1); // 200
            },
            fun: () => {
                console.log(this.name1); // 100
                console.log(this); // window
            }
        }
        // console.log(window.name1);  // 100 -> 如果上面是var name1 = 100 而不是let name1 = 100 这里是undefined
        obj.foo() // 200
        obj.fun() // 100 -> 如果上面是var name1 = 100 而不是let name1 = 100 这里是undefined
```



![image-20220618142410004](image-20220618142410004.png)

>`第17行代码尤其注意，是window。22或者23的声明方法 打印出来的都是window。借助temp变量，理解 ，就是window调用`

```js
const obj33 = {
                test() {
                    console.log(this); // obj33这个对象
                    return () => {
                        console.log(this); // test
                        console.log(this === obj33);
                    }
                }
            }
            let temp1 = obj33.test() // obj33对象 因为是箭头函数 父级函数是test，作用域是obj33
            temp1() // true
            var obj22 = {
                test: function getArrow() {
                    var that = this
                    console.log(this); // obj22对象
                    return function() {
                        console.log(this); // window
                    }
                }
            }
            // obj22.test()()
            let temp2 = obj22.test()
            temp2()
```



```js
// 4.2 箭头函数的指向2
	// 箭头函数
        let user = {
            username: 'lz',
            getUserName: function () {
                console.log(this.username);
            }
        }
        // user.getUserName() // lz
        
        // 箭头函数自身无作用域 => 父级 => 父级的username
        let user2 = {
            username: 'lz',
            getUserName: () => {
                console.log(this)
                console.log(this.username);
            }
        }
        // user2.getUserName() // undefined

        // 定时器的this指向 window
        // 通过that => this 能够解决问题
        let user3= {
            username: 'lz',
            getUserName () {
                // let that = this
                setTimeout(function () {
                    // console.log(that.username); 
                    console.log(this.username);
                })
            }
        }
        // user3.getUserName() // undefiend

        let user4= {
            username: 'lz',
            getUserName () {
                setTimeout(() => {
                    console.log(this.username);
                })
            }
        }
        // user4.getUserName() // lz
        
        
        // 1. 注释部分 this - window 
        // 2. 非注释部分 this - obj对象
        let user5 = {
            userName: 'zhangsan',
            getUserName() {
                // return function () {
                //     console.log(this); // window
                //     console.log(this.userName)
                // } // undefined
                
                return () => {
                    console.log(this); // user5对象
                    console.log(this.userName)
                } 
            }
        }
        user5.getUserName()() // zhangsan
```

```js
	// 5. 箭头函数不适合的场景

 	// 5.1 箭头函数没有原型
        let a = () => {
            return 1
        }
        function b() {
            return 2
        }
                
        // 箭头函数没有原型prototype
        // console.log(a.prototype) // undefined
        // console.log(b.prototype) // 有原型

        function Person3(name) {
            this.userName = name
        }
        Person3.prototype.sayHello = () => {
            console.log(this.userName);
        }
        let person = new Person3('li')
        person.sayHello() // undefined


        // 5.2 箭头函数 不能用作构造函数 这里会直接报错
        let Person2 = (name) => {
            this.userName = name
        }
        let p = new Person2('li') // Person2 is not a constructor 
        console.log(Person2.prototype);

```



call 绑定的this 第一个参数会默认忽略 如果不忽略，a就是m对象里面的

```js
         var obj = {
	    a: 100,
            b: function (n) {
                let f = (n) => n + this.a
                return f(n)
            },
            c: function (n) {
               let f = (n) => n + this.a
               let m = {
                   a: 20
               }
               return f.call(m, n)
            }
        }
        // this都指向 父级函数b或者c所在的作用域，就是整个obj对象
        console.log(obj2.b(1));  // 101
        console.log(obj2.c(1));  // 101
```



### 2.2  宏任务和微任务

【6-20】

- 事件循环
- 宏任务和微任务

```js
console.log(1)
setTimeout(function() => {
 	console.log(3)          
 })
 console.log(2)
```

`事件循环`

123,为啥？因为是JS是单线程的机制，如果碰到异步任务等待就会卡死，不想卡死，就把异步任务交给了浏览器。

浏览器去监听，异步任务。符合条件的放到任务队列

如果主线程代码执行完毕，空闲了就会执行任务队列的代码。执行完毕再去执行主线程的代码。

![image-20220620184250930](image-20220620184250930.png)

`宏任务和微任务`

1. 都属于异步任务。
2. 会先执行宏任务。主线程的所有代码都是算作第一个宏任务。全部执行完毕。再去执行这个宏任务所产生的微任务。
3. 如果没有了。再考虑执行下一次的宏任务
4. 宏任务和宏任务之间，会进行浏览器的渲染。



### 2.3 如何判断是否是数组?

【6-20】

1. toString()方法

```js
    function isArray(arg) {
        return Object.prototype.toString.call(arg) === '[object Array]'
    }
    let arr = [1, 2, 3]
    console.log(isArray(arr));

Object.prototype.toString.call([]).slice(8,-1)


 toString.call(123); //"[object Number]"
toString.call('abcdef'); //"[object String]"
toString.call(true); //"[object Boolean]"
toString.call([1, 2, 3, 4]); //"[object Array]"
toString.call({name:'wenzi', age:25}); //"[object Object]"
toString.call(function(){ console.log('this is function'); }); //"[object Function]"
toString.call(undefined); //"[object Undefined]"
toString.call(null); //"[object Null]"
toString.call(new Date()); //"[object Date]"
toString.call(/^[a-zA-Z]{5,20}$/); //"[object RegExp]"
toString.call(new Error()); //"[object Error]"
```

>直接 arr.toString() 是把数组转化为字符串。数组的原型上面 复写【重写】Object.prototype上面的方法。因此要用最根层级的

2. Array.isArray()

```js
    console.log(Array.isArray([1,2,3])); // true
```







4. 判断其它的数据类型 typeof？

typeof 判断 数字，字符，布尔，undefined,函数都ok，其它的都不行

判断数组 对象 正则 null 都是object

```js
        console.log(typeof 123); // number    
        console.log(typeof '12'); // string         
        console.log(typeof true); // boolean        
        console.log(typeof undefined); // undefined        
        console.log(typeof function fn () {}); // function      
        console.log(typeof []); // object        
        console.log(typeof {}); // object        
        console.log(typeof null); // object        
        console.log(typeof /^[123]$/); // object        
```



5. instanceof?

>1. constructor是原型对象的属性，它指向构造函数。对象实例，找不到属性或者方法，去原型上找，有constructor属性，指向的是该对象对应的构造函数。
>2. 因此能够判断实例.constructor === 构造函数？

```js
var num  = 123;
        var str  = 'abcdef';
        var bool = true;
        var arr  = [1, 2, 3, 4];
        var json = {name:'wenzi', age:25};
        var func = function(){ console.log('this is function'); }
        var und  = undefined;
        var nul  = null;
        var date = new Date();
        var reg  = /^[a-zA-Z]{5,20}$/;
        var error= new Error();

        function Person(){
        
        }
        let tom = new Person()
        // 下面全部是true哇
        console.log(
            tom.constructor==Person,
            num.constructor==Number,
            str.constructor==String,
            bool.constructor==Boolean,
            arr.constructor==Array,
            json.constructor==Object,
            func.constructor==Function,
            date.constructor==Date,
            reg.constructor==RegExp,
            error.constructor==Error
        );
```



6. for of 和 for in 能够区分对象和数组

for …… of如果用来输出对象 就会报错

```js
   let obj = {a:123, b: 34}
    let arr = [1, 2, 3, 4]
    for(let i of obj) {
        console.log(i);
    }

    for(let item of arr) {
        console.log(item);
    }
```



7. 自己写一个函数来进行匹配

```js
function gettype(obj) {
  var type = typeof obj;

  if (type !== 'object') {
    return type;
  }
  //如果不是object类型的数据，直接用typeof就能判断出来

  //如果是object类型数据，准确判断类型必须使用Object.prototype.toString.call(obj)的方式才能判断
  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, '$1');
}
console.log(gettype([1, 2, 3])); // Array
```



### 2.4 generator函数的学习

【6-22】

1. 写法 function后面紧跟*号;
2. 和普通函数不同，不会立即执行完毕，

```js
	function* go() {
            console.log(1);
            let a = yield 'a的值是null'
            console.log(2);
            let b = yield a
            console.log(3);
            return b
        }

	let it = go('a的值')
        // console.log(it);
        // 返回的是一个迭代器
        // 只有执行了next才会返回值

        // 1. 第一个next 使得函数往下执行 碰到yield后暂停，输出值是null
        // 2. 第二个next 使得函数往下执行 碰到yield后暂停，输出a的值是222
        // 3. 第三个next 使得函数往下执行 碰到yield后暂停，输出b的值是333
        let r1 = it.next('123') // 打印1 暂停
        console.log(r1); // 打印第一个yield后面的返回值
        let r2 = it.next('222') // 打印2 暂停
        console.log(r2); // 打印第二个yield后面的值
        let r3 = it.next('333') // 打印3 暂停
        console.log(r3); // 打印第二个yield后面的值
```



如何给上面式子的第一个a传递参数

```js
        function* go(str) {
            console.log(1);
            let a = yield str // 用str接住
            console.log(2);
            let b = yield a
            console.log(3);
            return b
        }
        let it = go('555')
```



一道Generator的面试题

```js
       function* test(num) {
            let x = 3 * (yield num + 1) 
            let y = yield x / 3
            return x + y + num
        }
        let n = test(6) // 这个6传递给形参 num值
        console.log(n.next()); // 7 第一个yield后面的结果
        console.log(n.next()); // NaN 因为并没有给第二个yield后面的x传递参数
        console.log(n.next()); // NaN 承接上面的 也是没有传递参数
```





一道面试题2：

>我疑惑的是下面的第一个n.next(3)是给第一个yield后面整体赋值，为啥不是给第二个yield后面整体赋值呢

```js
 	function* test(num) {
            let x = 3 * (yield num + 1) 
            let y = yield x / 3
            return x + y + num
        }
        let n = test(6) // 这个6传递给形参 num值
        console.log(n.next()); // 7 第一个yield后面的结果
        console.log(n.next(3)); // 3 // 3直接给第一个yield后面赋值 x = 3 * 3 = 9 因此下面的y = 3
        console.log(n.next(3)); // 18 = 9 + 3 + 6
```



### 2.5 深浅拷贝

【6-22】

```js
1. 含义：
浅拷贝：
- 赋值和浅拷贝有区别？
浅拷贝：
会创建一个新对象，这个新对象有着原始对象的一份精确拷贝。
如果属性是基本数据类型，拷贝的就是指。
如果属性是引用数据类型，拷贝的就是其地址。复杂数据类型拷贝地址，他们其实是共用同一块的内存空间。不管哪一个对象发生改变，另一个对象都会发生改变。

- 拷贝构造函数啥意思？



深拷贝：

```



`深拷贝的一种方案`：

```js
let a = {
    age: 1,
    jobs: {
        first: 'FE'
    }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = 'native'
console.log(b.jobs.first) // FE
```

这个方案有局限性：

- 不能够序列化函数
- 会忽略undefined
- 不能解决 循环引用的问题

### 2.6 JS有哪些bom对象

- document
- navigator
- history
- screen
- location









### 2.11  数据类型的隐式转化

1 最好都别使用`==`进行判断，会给程序造成很不必要的麻烦。

2 学习方法是，碰到了取记忆一个，而不是刻意去记

3 if语句 逻辑语句 数学运算语句都会出现隐式转换

```js
if (1 + '2' > 2) { console.log(2) }
```

```js
'1' || 2
'1'
```





### `手写`

### 2.100 防抖

- 概念

>目的是限制函数的执行次数。具体来说，就是函数执行的过程中，如果又被触发，就重新开始执行。
>
>例子：王者荣耀回城 - 回城过程中，受到伤害，回城时间重新开始计时。



- 实现

>1 能够实现限制执行的功能

页面一个按钮 + 监听click事件 + 点击触发 submit事件。如下写会立即触发fn函数，打印123 

```js
        let btn = document.querySelector('#btn')
        // 按钮点击的submit事件
        function submit () {
            console.log(123);
        }
        function debounce (fn) {
            fn()
        }
        // btn.addEventListener('click', fn) // fn是一个回调函数
        btn.addEventListener('click', debounce(submit)) // fn是一个回调函数
```



> 希望点击才触发 用到高阶函数 

```diff
        let btn = document.querySelector('#btn')
        // 按钮点击的submit事件
        function submit () {
            console.log(123);
        }
        function debounce (fn) {
+            return function () {
                fn()
            }
        }
        // btn.addEventListener('click', fn) // fn是一个回调函数
        btn.addEventListener('click', debounce(submit)) // fn是一个回调函数
```



> 难点1，timer变量什么时候声明【我们希望延时执行】

```diff
        let btn = document.querySelector('#btn')
        // 按钮点击的submit事件
        function submit () {
            console.log(123);
        }
        function debounce (fn,delay) {
            return function () {
+                let timer;
                if (timer) {
                    clearTimeout(timer)
                }
                timer = setTimeout(function () {
                    fn()
                }, delay)
            }
        }
        // btn.addEventListener('click', fn) // fn是一个回调函数
        btn.addEventListener('click', debounce(submit, 2000)) // fn是一个回调函数
```

timer变量如果声明在上面的位置，就会声明很多个timer变量，是形参。彼此之间是独立互不干扰的。假如点击很多次，只不过是`都`延续执行了



>成功延时执行

```diff
        let btn = document.querySelector('#btn')
        // 按钮点击的submit事件
        function submit () {
            console.log(123);
        }
        function debounce (fn,delay) {
+           let timer; // 换到这里执行 下面的函数是闭包，使用这个变量，公用一个外部变量
            return function () {
                if (timer) {
                    clearTimeout(timer)
                }
                timer = setTimeout(function () {
                    fn()
                }, delay)
            }
        }
        // btn.addEventListener('click', fn) // fn是一个回调函数
        btn.addEventListener('click', debounce(submit, 2000)) // fn是一个回调函数
```



>当我们希望传递 点击事件对象进入submit函数

```diff
        let btn = document.querySelector('#btn')
        // 按钮点击的submit事件
        function submit (e) {
            console.log(123);
+           console.log(e); // 这里传递 e是打印 undefined
        }
        function debounce (fn,delay) {
            let timer;
            return function () {
                if (timer) {
                    clearTimeout(timer)
                }
                timer = setTimeout(function () {
                    fn()
                }, delay)
            }
        }
        // btn.addEventListener('click', fn) // fn是一个回调函数
        btn.addEventListener('click', debounce(submit, 2000)) // fn是一个回调函数
```



>只有这样传递 才能打印的到

```diff
        let btn = document.querySelector('#btn')
        // 按钮点击的submit事件
        function submit (e) {
            console.log(123);
            console.log(e);
        }
        function debounce (fn,delay) {
            let timer;
+            return function (e) { // 这个打印e 下面的fn(才能访问拿到e) 传递到fn => submit方法里去 => 是btn点击的事件对象
                if (timer) {
                    clearTimeout(timer)
                }
                timer = setTimeout(function () {
+                    fn(e)
                }, delay)
            }
        }
        // btn.addEventListener('click', fn) // fn是一个回调函数
        btn.addEventListener('click', debounce(submit, 2000)) // fn是一个回调函数
```



这里的this指向问题 和 传参问题 有点手无足措





# Number

Number转换对象类型的值 内部先调用valueOf()函数 返回值，并且判断返回的值是否是Number类型 

如果不能，再调用toString()函数获取返回值 并且判断是否是Number类型，如果也不满足，则返回NaN









toString()方法





valueOf()方法





>隐式转换的规则？







# parseInt

内部先将一个值转化为字符串，再转化为数字

前置匹配，如果一个数，'abc' 直接就是NaN

如果一个数'1abc' 转化为1

如果有算数运算符parseInt('5 * 6') 就是5

如果是parseInt(5 * 6) 就是30

如果有浮点数，就会取整数部分





进制

```diff
parseInt('1',0) // 任何数以0为基础 都是本身 返回1
parseInt('2',1) // 第二个参数的范围是2-36 没有 1 返回NaN
parseInt('3',2) // 把3当作二进制解析，但是二进制没有3只有0和1 因此返回NaN
parseInt('4',3) // 把4当作3禁止解析，但是4无法被当作3进制 返回NaN
```



>3进制长什么样？



map使用

```diff
      var arr = ["1", "2", "3", "4"];
      var result = arr.map(function (val) {
+        return parseInt(val, 10); // 第二个参数必须指明是10进制 不然报错
      });
      console.log(result);
```





# parseFloat

1. 会忽略空格
2. parseFloat('f123.11') 是NaN 没有进制概念
3. parseFloat('  123.11.2') 是12.11 只会取前面的部分





总结不同：

1. Number和 后面两个 ，前者对整个值进行比较 后者可以前置匹配
2. 后两个比较 parseInt有进制的概念 ，转换为整数；parseFloat没有进制 只有一个参数 转化为浮点数





# isNaN和Number.isNaN

NaN===NaN 是false



ES5 isNaN

ES6 Number.isNaN



isNaN 判断一个传入值 是数字吗？是的话 false 否则返回true



 Number.isNaN只有传入的值是NaN才会返回false ； 但是ES5的isNaN null undefined NaN 返回的都是false





如何在ES5的环境使用 Number.isNaN()





# git rebase 和 git merge

都是用于从一个分支获取内容 合并到当前分支



merge会创建一个新的commit 

如果合并时发生冲突，修改后重新合并即可



使用rebase

会合并之前的commit历史 更加的简洁





# git revert 和 reset

git reset 回退到某个版本

git revert 撤销对某个版本的修改







# DNS域名解析

首先会在`浏览器的缓存`中查找对应的ip地址，如果查找到直接返回，找不到，下一步

将请求发给本地的DNS服务器，在`本地的域名服务器缓存`中查询，找到直接返回，找不到，下一步

本地的DNS服务器向`根域名服务器`发送请求，根域名服务器会返回一个所查询域的顶级域名服务器

本地DNS服务器向顶级域名服务器发送请求，接受请求的服务器查询自己的缓存，有记录，就返回查询结果，没有就返回下一级`权威域名服务器`的地址

本地DNS服务器`向权威域名服务器发送请求，返回对应的结果

本地的DNS服务器将接受到的结果放在缓存中下一次使用

返回给浏览器使用







# String

1. 字面量



2. String函数

```js
console.log(String(123)); // '123'
console.log(String(null)); // 'null'
console.log(String(undefined)); // 'undefined'
console.log(String(true)); // 'true'
console.log(String(false)); // 'false'
```



3. new String

返回String的实例对象 值是对应的值

```js
console.log(new String(123));
console.log(new String(true));
```





区别：

第三种 比较是否相等时，比较的是地址，



此外：

String的实例对象能够访问到 indexOf subString这些方法

而'abc'.indexOf()也能够访问到，因为js会自动将基本字符串转化为字符串对象，形成包装的类型





# 字符串常见的算法



## 字符串翻转

```js
// 1. 法一 转化为数组 再reverse
function strReverse(a) {
    return a.split('').reverse().join('')
}
console.log(strReverse('abcde'));

// 2. Array.from()
function strReverse2(a) {
    var arr = Array.from(a)
    return arr.reverse().join('')
}
console.log(strReverse2('abcde'));

// 3. 利用字符串本身携带的charAt
function strReverse3(a) {
    let result = '';
    for (let i = a.length - 1; i >= 0; i--) {
        result += a.charAt(i)
    }
    return result
}
console.log(strReverse3('abcde'));

// 4. 不借助api 如何实现？
```





## 字符串中出现次数最多的





## 字符串去重



## 回文字符串







# 运算符

## 1. 等于运算符



**三个等于号**

new之后，变为对象，数据类型不同 会直接返回false

```js
console.log(1 === Number(1));
console.log('abc' === String('abc'));

// 即便是两个==也是false
console.log(1 === new Number(1)); // false
console.log('abc' === new String(1)); // false
```





```js
// null 和 undefined的比较
console.log(undefined === null); // false

// 引用类型的比较
var a = []
var b = a
console.log(a === b); // true
console.log(new String('abc') === new String('abc')); // false
```



```js
function Person(userName) {
	this.userName = userName;
}
var p1 = new Person("wangwu");
var p2 = new Person("wangwu");
console.log(p1 === p2);//false  两个不同对象，地址不相同
```





**二个等于号**

```js
1=='1' //true
'222'==222 //true

null==undefined //true
null==1 //false
undefined==2 //false


'1'==true
'2'==true //false
'0'==false //true
```





## 2. type运算符

```js
1 undefined
typeof undefined // 'undefined'
typeof a // 'undefined'

2. 
var b=true
typeof b //"boolean"

3. 
typeof 666 //number
typeof 66.66 //number
4. 
typeof 'aaa' //string
typeof '' //string

5. 
function fun(){}
typeof fun // "function"

var fun2=function(){}
typeof fun2 // "function"

----有时候括号是必须的，能够解决优先级的问题
var num=123
typeof (num + 'hello')// string
typeof num + " hello"  //"number hello"

typeof 6/2 // NaN 因为是 'number' / 2 是 NaN


类也是function  原理依旧是原型继承
class Obj{
}
typeof Obj // "function"


6. 处理object类型
var arr=[1,2,3]
typeof arr // "object"

var arr2=new Array()
typeof arr2 //"object"

处理null
typeof null //object

```





## 3. 常见判空法



判断变量是否为空对象

1. if语句直接加一个!，



```js
if (!x)
    
变量为null
变量为undefined
变量为空字符串''
变量为数字0
变量为NaN
```



2. 

```js
if (obj === null)
if (obj == null) // null和undefined都可以进行判断
```



3. hasOwnProperty判断

```js
function isEmpty(obj) {
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            return false
        }
    }
    return true
}
let username = {
    name: '123'
}
let username2 = {
}
function Person (name) {
    this.name = name
}
console.log(isEmpty(username)); // false 说明 username身上有自己的属性
console.log(isEmpty(username2)); // true 说明 username身上有自己的属性
console.log(isEmpty(obj)); // false 构造函数的实例对象 身上也有自己的属性

```





4.判断变量是不是空数组

arr.length



5. 变量是否是空字符串

```js
str = ''

str.trim().length === 0
```





6. 变量为0

```js
!(Number(num)&&num)==true
```





流程控制

```js
  <script>
      function getStringValue(str) {
        switch (str) {
          case "1":
            console.log("a");
            break;
          case "2":
            console.log("b");
            break;
          case "3":
            console.log("c");
            break;
          default:
            console.log("d");
        }
      }
      getStringValue("2"); //b
      getStringValue("5"); //d
    </script>
```



getStringValue(3) // 返回的是'd'

getStringValue(new String(3))// 返回的是'd'

getStringValue(String(3)) // 返回的是'c'













# Array类型
