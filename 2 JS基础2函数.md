## call方法



## apply方法



## bind方法

### 使用



普通函数调用的情况

this指向的就是sub函数

```js
// bind函数的使用
function add(a, b, c) {
    // console.log(this); // 打印的是sub函数
    return a + b + c
}
function sub(a, b) {
    return a - b
}
console.log(add.bind(sub, 1, 2, 3)()); // 3
console.log(add.bind(sub, 3)(1, 2)); // 3 这样写也是ok的 bind返回的还是一个函数 需要再次调用
```





构造函数调用的情况

```js
function Person(a, b) {
    this.a = a
    this.b = b
    console.log('this', this); // 这里的this指向的是构造函数的实例对象
    console.log('a', a);
    console.log('b', b);
    this.add = function () {
        console.log('111');
    }
}
let obj = {
    name: 10,
    age: 100
}
let person = Person.bind(obj, 200)
let re = new person(10, 20)
re.add()
```





### 手写

注意点：

1. add.bind(obj, 1)(2, 3) 要能够兼容这种情况
2. 如果传入的构造函数，不能够改变this 指向，this应该仍旧指向实例；如果传入的是普通的函数，就可以改变this的指向

以下是没有注释的版本

```js
Function.prototype.myBind = function (context) {
    let args = [...arguments].slice(1)
    let fn = this
    function Fn() {
        return fn.apply(
            this instanceof Fn ? this : context,
            args.concat(...arguments)
        )
    }
    Fn.prototype = Object.create(this.prototype)
    return Fn
}
```



以下是测试用例

```js
function add(num1, num2) {
    debugger
    console.log(this);
    console.log(num1 + num2);
}
function sub(num1, num2) {
    console.log(num1 - num2);
}
add.myBind(sub)(6, 3)

function Person(a, b, c) {
    debugger
    this.a = a
    this.b = b
    console.log('this', this); // 打印的是person函数 person函数就是Fn函数
    console.log('a', a);
    console.log('b', b);
    console.log('c', c);
    this.add = function () {
        console.log('111');
    }
}
Person.prototype.say = function () {
    console.log('say');
}
let person = Person.myBind(sub, 200)
let re = new person(10, 20)
re.add()
re.say() // 能够打印say
```



以下是有注释的版本

```js
Function.prototype.myBind = function (context) {
    debugger
    // 2 为什么要保存当前函数的引用? 获取其余传入的参数
    let args = [...arguments].slice(1)
    // 3 保存当前函数的引用 比如这里是add函数
    let fn = this
    // 4 创建一个函数
    function Fn() {
        // 5 根据调用方式 传入不同的绑定值
        //   如果fn是构造函数，不改变this指向, this此时指向构造函数Person【利用instanceof进行判断】
        //   如果普通函数，就把context传给fn执行，也就是普通函数add执行时，this改为context“sub函数”
        // 6. args.concat(arguments)是为了合并参数 合并返回的函数()和调用的函数 传递的参数
        // console.log('33行this', this); // 是Fn函数的实例
        return fn.apply(
            this instanceof Fn ? this : context,
            args.concat(...arguments)
        )
    }
    // 7. 为了使得新创建的函数实例能够继承调用函数的原型上面的属性和方法
    // console.log(this);
    // console.log(this.prototype);
    Fn.prototype = Object.create(this.prototype)
    return Fn
}
```



>Fn.prototype = Object.create(this.prototype)
>
>这句代码，只针对构造函数有效，针对普通函数是无效的，为什么？
>
>1. 我的理解是，构造函数用bind调用时，会返回对象的实例，我们可以通过这个实例对象去访问到构造函数原型上面的方法。我们希望这样做，而bind手写的里面的Fn是我们新创建的函数，我们要“手动”让它继承“this”也就是构造函数Person的prototype，还记得new关键字吗？执行new 不也是让 新创建的对象的obj的proto指向构造函数的prototype嘛？我觉得这里是有点像的。
>2. 而普通函数，执行，返回的函数，它是不会返回一个对象啥的。而构造函数内部是会返回一个对象实例的。







## 闭包

闭包的概念

>1 内层函数访问了外层函数的变量，就可以形成闭包。
>
>2 具体一点：
>
>- 函数A内部声明并返回函数B
>- 函数B被外部使用时，调用了函数A里面的变量值
>- 函数B不能被释放，函数A里面的该变量也不会被释放。闭包产生。函数B是闭包



### 1 第一步，知道 词法作用域的概念

>《你不知道的JavaScript 上卷》
>
>作用域：JS需要有一套良好的设计规则，来存储和访问变量，这个`规则`就是作用域。
>
>词法作用域：由你在写代码时，将变量和块作用域写在哪里的位置来决定的。词法分析器在处理代码时，会保持作用域不变。



我的理解是：

1. 不论这个函数最终在哪里被调用，他的作用域的查找都是在他定义的地方决定的。





仔细观察下面两段代码，一个是在外部执行，一个是在内部执行。打印都是local scope。

不管函数fn()调用是在里面还是在外面，他的作用域都是在函数checkscope()内层就决定好。都是访问的checkscope这个里面的变量

```diff
        var scope = 'global scope'
        function checkscope() {
            var scope = 'local scope'
            function fn() {
                console.log(scope);
                return scope
            }
+           return fn()
        }
+        checkscope()

        var scope = 'global scope'
        function checkscope2() {
            var scope = 'local scope'
            function fn() {
                console.log(scope);
                return scope
            }
+            return fn
        }
+        checkscope2()()
```





### 2. 理解执行上下文和作用域链

>当我们调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用arguments和其他的命名参数来初始化这个函数的活动对象，外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象。直到全局执行上下文才终止。
>
>--《红宝书》



什么意思？

1. `可执行上下文`：分为全局上下文和局部上下文。就理解他是一个`执行的环境`。
2. `变量对象`：可执行上下文的概念有点抽象。但你要知道，他里面有一个变量对象，这个变量对象厉害了，当前的上下文里面的所有的**变量和函数**都存在这个变量对象里面。
3. `作用域链`：**函数**代码执行时，会创建变量对象的一个作用域链。这个作用域链是理解闭包的关键，老铁要注意了，**当前可执行上下文**里面的变量对象是摆在作用域链的第一位的，第二位才是对上一级的上下文里面的变量对象的引用。
4. 第一小节提到的`词法作用域`与这些概念有什么关系：我认为想提醒我们的是，这些个变量的**引用包含关系**，是**函数定义时**，就创建好的。尽管可执行上下文是函数调用时，才有的。

![image-20220817085855208](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4575/image-20220817085855208.png)







### 3 第三步，知道闭包是什么与写出具体的例子

>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域以外执行的，这时，就产生了闭包
>
>--《你不知道的JavaScript 上卷》



>闭包通常指的是，引用了另一个函数作用域中变量的函数。
>
>--《红宝书》



1. 我觉得红宝书的概念更好理解，闭包是一个函数，这个函数引用了另一个函数作用域中的变量。
2. 但是我觉得《你不知道的JavaScript 上卷》对于闭包的要求更高一些，是要在“当前词法作用域”以外的地方执行，我更倾向于这个概念。闭包既要引用到上一个词法作用域里面的变量，也要在当前作用域以外的地方被使用。



据此，我们判断，下面例子，严格来说，不是闭包

```js
        function fn () {
            let num = 1
            function inner () {
                console.log(num);
            }
        }
        fn()
```



#### 函数被返回

这是典型的闭包

```js
        function fn() {
            var num = 10;
            function inner () {
                console.log(num); // 10
            }
            return inner
        }
        var f = fn();
        f();
```



#### 函数作为参数被传递

这也是闭包，来自《你不知道的JavaScript 上卷》

```js
function fn1() {
    var a = 2
    function baz() {
        console.log(a);
    }
    // 把baz函数作为参数传递给bar函数 在这里调用bar函数，
    bar(baz)
}
function bar(fn) {
    fn() // 大哥快看呀，这也是闭包
}
fn1()
```





这个也是闭包，来自《你不知道的JavaScript 上卷》

```js
// 函数作为参数被传递
let fn
function fn1() {
    var a = 2
    function baz() {
        console.log(a);
    }
    fn = baz // baz作为参数传递给全局变量fn
}
function bar() {
    fn() // 大哥快看呀，这也是闭包
}
fn1()
fn() // 调用fn
```





#### 回调函数中的闭包

```js
function wait(message) {
    setTimeout(function () {
        console.log(message); // 这里访问了上一层作用域的message变量
    }, 1000)
}
wait('我也是闭包哦~')
```



#### jQuery中的闭包

```js
// jQuery中的闭包
function setupBot(name, selecor) {
    $(selector).click(function activator() {
        console.log('这里能够访问到上一层的', name);
    })
}
setupBot('123', '$id')
```



#### 不恰当的例子

确实创建了闭包，但是 这个例子不是特别恰当，仅仅是通过作用域链的机制查找到了a变量(没有在其它的作用域中)

```js
var a = 2;
(function IIFE() {
    console.log(a);
})()
```



错题

```js
// 我猜 答案是 6 7 8 9 10
// 妈呀 ！ 结果答案是 5 5 6 7 8 9 10 不仅漏掉了一个5，应该是i等于5就退出了循环了
for (var i = 0; i < 5; i++) {
    setTimeout(function () {
        console.log(i++);
    }, 4000)
}
console.log(i);
```



### 4 闭包的作用

>实现数据的私有

验证:

1 下面，count是全局变量 很容易被篡改



```js
let count = 1;
function fn() {
  count++
  console.log('打印了' + count + '次函数')
}
fn()
fn()
如果在外面
count = 1000
fn() =>打印了1000次函数 但是并没有打印1000次函数 因此不合理
```



2 下面是闭包 外面无法随意篡改

```js
function fn () {
    let count = 0
    function inner () {
        count++
        console.log('函数被调用了' + count + '次');
    }
    return inner
}
let result = fn()
result()
result()
result()
count = 1000 此时并没有卵用

result = null // 的情况
```

>注意：最终 result = null 后 ，能够释放内存。断开了之前对于内部函数的引用



3 类里面方法的私有封装

下面构造函数 name是let声明，不是this.name= 

如果是this.， 那么每次都是通过p.name就能够修改，

如果是let，p.name就是错的，必须通过每个实例的，方法获取 方法去set

p.getName => 外部访问到getName方法 => 访问到name变量 => 闭包是getName函数

```javascript
function Person() {
  // 以 let 声明一个局部变量，而不是 this.name
  // this.name = 'zs'     =>  p.name
  let name = 'hm_programmer' // 数据私有
  
  this.getName = function(){ 
    return name
  }
  
  this.setName = function(value){ 
    name = value
  }
}

// new:
// 1. 创建一个新的对象
// 2. 让构造函数的this指向这个新对象
// 3. 执行构造函数
// 4. 返回实例
const p = new Person()
console.log(p.getName()) // hm_programmer

p.setName('Tom')
console.log(p.getName()) // Tom

p.name // 访问不到 name 变量：undefined
```



4 解决var历史遗留问题



为什么使用立即执行函数 能够解决变量存不住的问题？

```js
1 先创建 全局的上下文环境 创建全局的作用域链，但是这里只有变量对象i
2 for循环开始 创建立即执行函数的 执行上下文 => 创建了作用域链[立即执行函数变量对象 就只有x 被i赋值 + 全局变量对象]
3 定时器执行 => 交给浏览器执行，放到任务队列排队
4 立即执行上下文弹出
5 循环进入下一个，创建一个新的立即执行函数上下文 => 创建作用域链 ……

```



```javascript
for(var i = 1; i <= 5; i++) {
  setTimeout(()=> {
    console.log(i++)
  }, i * 1000)
}
  把i理解为全局变量 但是使用let关键字就不是
  打印5个6 因为var声明的变量会影响全局，是遗留问题，定时器执行完毕，里面的
函数【回调函数】会去打印的是最后的i

for(var i = 1; i <= 5; i++) {
  (function(num) {
    setTimeout(()=> {
      console.log(num++)
    }, num * 1000)
  })(i)
}
console.log(num)

// 1. 函数套函数 
// 内部函数 - 定时器的回调;
// 外部函数 - 立即执行函数
// 相当于访问的外部的变量
// 2. 直接用let可以解决，上面这个作用不重要


```

5 解决小li的打印问题

```html
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
    </ul>
```



```js
        let list = document.getElementsByTagName('ul')[0].children
        for (var i = 0; i < list.length; i++) {
            list[i].onclick = function () {
                console.log(i);
            }
        }
// 打印都是5 因为回调执行时，for循环已经结束，此时i是5，打印的是最后的i
```





法1：使用闭包解决

```js
        for (let i = 0; i < list.length; i++) {
            (function (index) {
                list[index].onclick = function () {
                    console.log(index);
                }
            })(i)
        }
```

回调函数能够访问到外面的立即执行函数体的index变量，

该变量不会被立即释放，回调函数是闭包函数

每一轮for循环，产生一个立即执行函数，存入一个i变量





法2:var -> let

因为let有块级作用域。

for循环会形成5个块级作用域，彼此里面的变量独立。

点击小li，触发回调，函数根据作用域链访问上一层的i变量， 是对应的块级作用域的变量，不是全局变量



法3：利用自定义属性

```diff
        let list = document.getElementsByTagName('ul')[0].children
        for (let i = 0; i < list.length; i++) {
+            list[i].index = i
+            list[i].onclick = function () {
+                console.log(this.index);
            }
        }
```

给每一个li节点 存储一个index属性，打印对应的index属性即可





5 闭包面试题2

```js
        var userName = 'zhangsan'
        let person = {
            userName: 'lisi',
            method: function () {
                return function () {
                    return this.userName
                }
            }
        }
        console.log(person.method()());
        // 1 请注意 如果全局下 使用的是let userName = 'zhangsan' 打印的就是undefined
        //   为什么? let const 关键字 变量不是绑定到window上面 而是绑定在script对象
        //   var会
        //   全局对象 local对象【局部】 script对象是平行关系

        /*
           1 打印全局
             因为是window调用最终的函数
           2 that = this 或 箭头函数 能够使得打印 lisi
        */
```



6 闭包查找从函数的定义位置开始查找

```js
// 打印的是?
function print(fn) {
    var a = 200
    fn()
}
var a = 100
function fn() {
    console.log(a);
}
print(fn)
// 100 闭包查找 => 从函数定义的地方开始查找 不是执行的地方开始查找
```



### 5 闭包的优点

能够实现变量和方法的封装，保护它们的安全

能够缓存变量





### 6 闭包的缺点

会造成内存的 浪费



![image-20220721100029871](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/4575/image-20220721100029871.png)







# 原型链







